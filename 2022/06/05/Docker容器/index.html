<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="晓江"><meta name="copyright" content="晓江"><meta name="generator" content="Hexo 5.0.0"><meta name="theme" content="hexo-theme-yun"><title>Docker容器 | 云端小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.16/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_stqaphw3j4.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => <!-- hexo-inject:begin --><!-- hexo-inject:end -->{
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><link rel="shortcut icon" type="image/svg+xml" href="/icon.jpg"><link rel="mask-icon" href="/icon.jpg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><link rel="alternate" href="/atom.xml" title="云端小站" type="application/atom+xml"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"云端小站","version":"0.9.4","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"}};
  </script><meta name="description" content="Docker容器">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker容器">
<meta property="og:url" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="云端小站">
<meta property="og:description" content="Docker容器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210218205343872.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210218211334994.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210218220035693.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210218220826134.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221110739417.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221111649221.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221111759852.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221113029255.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221113237929.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221113956329.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221114030975.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221114219761.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221114717793.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221115243553.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221115359405.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221115710693.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221120152725.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221132848506.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221135305077.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221140220409.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221140501929.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221140659054.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221142525271.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221144028836.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222194426678.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222195239209.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222211347895.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222213515808.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222213117135.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224114525865.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224120856019.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224120905711.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224121140385.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224125709788.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224130039423.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224130152827.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224130838730.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224130930288.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224141840002.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224141943651.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313095405902.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313095817664.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313100226470.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313100636010.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313100828231.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313101426464.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313102020837.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313102242966.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313104046775.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313104432119.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313105411779.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320163453833.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320163735466.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320164253752.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320170918960.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320171116706.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323104917217.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323105001667.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323105853180.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323110159402.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323110527647.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323110709008.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323110900556.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323123800056.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323124140288.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323124211684.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323124453637.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323124542728.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323125156803.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323125814307.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323131445769.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323131633410.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323132106770.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323132149674.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220527225921014.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220527230035128.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220527231105839.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220528103602675.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220528124707258.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220528132801081.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220528134158091.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220529004715495.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220529004942637.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220529005138938.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531200714897.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531200649800.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531203510027.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531205805983.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531222907177.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220601110737543.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220601113502498.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220601113611511.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220601114205873.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220602003144618.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220602003226575.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220602003505172.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603145510984.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603145555686.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603145657292.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603150044156.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603150306528.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603160708922.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603151515840.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603155939355.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603154239954.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603230617079.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604000636559.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604001705002.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604002118769.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604002613317.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604004120694.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604004856682.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604005054660.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604110409054.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604110713257.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604110503756.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604111521973.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604111655312.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604112013286.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604113210142.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604113429400.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604113731006.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604124515522.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604124609840.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604124749049.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604125635082.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604203411018.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604211937224.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604212636066.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604212904002.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604213200537.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604213442546.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604213513944.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604213730948.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220605002518856.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220605002747710.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220605214030601.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220605214116103.png">
<meta property="article:published_time" content="2022-06-05T14:29:21.000Z">
<meta property="article:modified_time" content="2022-06-05T14:32:25.270Z">
<meta property="article:author" content="晓江">
<meta property="article:tag" content="镜像">
<meta property="article:tag" content="容器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210218205343872.png"><script src="/js/ui/mode.js"></script><link rel="stylesheet" href="/css/prism.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="晓江"><img width="96" loading="lazy" src="/icon.jpg" alt="晓江"></a><div class="site-author-name"><a href="/about/">晓江</a></div><a class="site-name" href="/about/site.html">云端小站</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">47</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">16</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">49</span></a></div><a class="site-state-item hty-icon-button" href="https://lxjblog.gitee.io/myblog" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/wechat/" title="微信" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1256240778&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Xiaojiang-l" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/playlist?id=5157675042" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:1256240778@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8"><span class="toc-text">Docker容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Docker%E6%A6%82%E8%BF%B0"><span class="toc-text">1、Docker概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0"><span class="toc-text">为什么会出现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">Docker的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-text">Docker能干嘛</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Docker%E5%AE%89%E8%A3%85"><span class="toc-text">2、Docker安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-text">Docker的基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Docker"><span class="toc-text">安装Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-text">阿里云镜像加速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BEHelloWord%E6%B5%81%E7%A8%8B"><span class="toc-text">回顾HelloWord流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">底层原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">3、Docker的常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4"><span class="toc-text">帮助命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">镜像的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">容器命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-text">常用的其他命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%AE%89%E8%A3%85Nginx"><span class="toc-text">4、安装Nginx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AE%89%E8%A3%85Tomcat"><span class="toc-text">5、安装Tomcat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E9%83%A8%E7%BD%B2-ES-Kibana"><span class="toc-text">6、部署 ES + Kibana</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-text">7、可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Docker%E9%95%9C%E5%83%8F%E8%AE%B2%E8%A7%A3"><span class="toc-text">8、Docker镜像讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">镜像是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-text">Docker镜像加载原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">分层原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81commit%E5%AE%B9%E5%99%A8"><span class="toc-text">9、commit容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">10、容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">什么是容器数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">使用数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%89%E8%A3%85MySQL"><span class="toc-text">实战：安装MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E5%92%8C%E5%8C%BF%E5%90%8D%E6%8C%82%E8%BD%BD"><span class="toc-text">具名和匿名挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86-Dockersfile"><span class="toc-text">初识 Dockersfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-text">数据卷容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81DockerFile"><span class="toc-text">11、DockerFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerFile-%E4%BB%8B%E7%BB%8D"><span class="toc-text">DockerFile 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerFile-%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">DockerFile 构建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerFile-%E6%8C%87%E4%BB%A4"><span class="toc-text">DockerFile 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%B5%8B%E8%AF%95"><span class="toc-text">实战测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C-Tomcat-%E9%95%9C%E5%83%8F"><span class="toc-text">制作 Tomcat 镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%88%B0-DockerHub"><span class="toc-text">发布到 DockerHub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-text">发布到阿里云</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81Docker%E7%BD%91%E7%BB%9C"><span class="toc-text">12、Docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker0"><span class="toc-text">Docker0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%93link"><span class="toc-text">–link</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-text">自定义网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A"><span class="toc-text">网络连通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%EF%BC%9A%E9%83%A8%E7%BD%B2-Redis-%E9%9B%86%E7%BE%A4"><span class="toc-text">实战：部署 Redis 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%93%E5%8C%85%E6%88%90Docker%E9%95%9C%E5%83%8F"><span class="toc-text">SpringBoot微服务打包成Docker镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81Docker-%E5%B0%8F%E7%BB%93"><span class="toc-text">13、Docker 小结</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="晓江"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="云端小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Docker容器</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-06-05 22:29:21" itemprop="dateCreated datePublished" datetime="2022-06-05T22:29:21+08:00">2022-06-05</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">服务器</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/%E9%95%9C%E5%83%8F/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">镜像</span></a><a class="tag" href="/tags/%E5%AE%B9%E5%99%A8/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">容器</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://img-blog.csdnimg.cn/20210628000220859.jpg"></div><span class="author-name">晓江</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210218205343872.png" alt="image-20210218205343872" loading="lazy"></p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="1、Docker概述"><a href="#1、Docker概述" class="headerlink" title="1、Docker概述"></a>1、Docker概述</h2><p>官网：<a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210218211334994.png" alt="image-20210218211334994" loading="lazy"></p>
<p>仓库地址：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h3 id="为什么会出现"><a href="#为什么会出现" class="headerlink" title="为什么会出现"></a>为什么会出现</h3><p><strong>之前开发一款产品：</strong></p>
<ul>
<li>开发–上线，两套环境！应用环境！应用配置！</li>
<li>问题：我在我的电脑上可以运行，换个环境却不行！版本更新，导致服务不可用！</li>
<li>环境配置十分麻烦，每一个机器都要部署环境（集群Redis、ES、Hadoop……）</li>
<li>发布一个项目jar（需要部署Redis、MySQL、jdk、ES）</li>
<li>之前在服务器配置应用环境，配置麻烦，不能跨平台</li>
<li>开发做jar，运维配置环境！</li>
</ul>
<p><strong>现在：</strong></p>
<ul>
<li>项目带上环境安装打包</li>
<li>开发打包部署上线，一套流程做完</li>
<li>java – apk – 发布（应用商店） – 下载安装即可用</li>
<li>java – jar（环境） – 打包项目带上环境（镜像） – Docker仓库：商店 – 下载我们发布的镜像 – 直接运行即可</li>
</ul>
<p><strong>Docker给以上问题，提供了解决方案！</strong></p>
<p>Docker的思想就来自于集装箱！</p>
<p>之前：Jre – 多个应用（端口冲突） – 原来是交叉的！</p>
<p>隔离：Docker核心思想！打包装箱！每个箱子相互隔离！</p>
<p>Docker通过隔离机制，可以将服务器利用到极致！</p>
<h3 id="Docker的优势"><a href="#Docker的优势" class="headerlink" title="Docker的优势"></a>Docker的优势</h3><p><code>虚拟机</code>：在window中安装一个VMware，通过这个软件我们可以虚拟出一台或者多台电脑！但是笨重！</p>
<p>虚拟机也属于虚拟化技术，但是占用内存大！</p>
<p><code>Docker</code>：隔离，镜像（最核心的环境 + jdk + mysql）十分小巧，运行镜像就可以，几个M或者KB，秒级启动！</p>
<p> Docker 基于Go语言开发！开源项目！</p>
<h3 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h3><blockquote>
<p>之前的虚拟机技术</p>
</blockquote>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210218220035693.png" alt="image-20210218220035693" loading="lazy"></p>
<p><strong>缺点：</strong></p>
<ol>
<li>资源占用多</li>
<li>冗余步骤多</li>
<li>启动很慢</li>
</ol>
<blockquote>
<p>容器化技术</p>
</blockquote>
<p>容器化技术不是模拟的一个完整的操作系统</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210218220826134.png" alt="image-20210218220826134" loading="lazy"></p>
<p>比较Docker 和 虚拟机技术的不同：</p>
<ul>
<li>传统虚拟机，虚拟一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器中的应用直接运行在 宿主机 的内容，<strong>容器时没有自己的内核的</strong>，也没有虚拟我们的硬件，所以就轻便了</li>
<li>每个容器间时相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响</li>
</ul>
<blockquote>
<p>DevOps（开发、运维）</p>
</blockquote>
<p><strong>应用更快速的交付和部署</strong></p>
<ul>
<li>传统：一堆帮助文档，安装程序</li>
<li>Docker：打包镜像发布测试，一键运行</li>
</ul>
<p><strong>更便捷的升级和扩缩容</strong></p>
<ul>
<li>使用了Docker之后，我们部署应用就和搭积木一样</li>
<li>项目打包为镜像，扩展 只需要在另一个服务器中一键运行</li>
</ul>
<p><strong>更简单的系统运维</strong></p>
<ul>
<li>在容器化之后，我们的开发，测试环境都是高度一致的</li>
</ul>
<p><strong>更高效的计算资源利用</strong></p>
<ul>
<li>可以将服务器的性能应用到极致</li>
<li>Docker 是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例</li>
</ul>
<h2 id="2、Docker安装"><a href="#2、Docker安装" class="headerlink" title="2、Docker安装"></a>2、Docker安装</h2><h3 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h3><p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221110739417.png" alt="image-20210221110739417" loading="lazy"></p>
<p><strong>镜像（image）：</strong></p>
<ul>
<li>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）</li>
</ul>
<p><strong>容器（container）：</strong></p>
<ul>
<li>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的</li>
<li>启动，停止，删除，基本命令</li>
<li>目前就可以把这个容器理解为就是一个简易的Linux系统</li>
</ul>
<p><strong>仓库（repository）：</strong></p>
<ul>
<li>仓库就是存放镜像的地方！</li>
<li>仓库分为共有仓库和私有仓库！</li>
<li>Docker Hub（默认是国外的）</li>
<li>阿里云…都有容器服务（配置镜像加速）</li>
</ul>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><blockquote>
<p>环境准备</p>
</blockquote>
<ol>
<li>需要Linux基础</li>
<li>CentOS 7</li>
<li>使用Xshell连接远程服务器</li>
</ol>
<blockquote>
<p>环境查看</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 查看系统内核版本，需要3.10以上
[root@iz2ze2js0u6m077omgcbzmz /]# uname -r
3.10.0-1127.19.1.el7.x86_64</code></pre>
<pre class=" language-shell"><code class="language-shell"># 系统配置
[root@iz2ze2js0u6m077omgcbzmz /]# cat /etc/os-release 
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"</code></pre>
<blockquote>
<p>安装</p>
</blockquote>
<p>帮助文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a></p>
<p>需要选择Linux系统的版本</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221111649221.png" alt="image-20210221111649221" loading="lazy"></p>
<p>然后选择CentOS版本</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221111759852.png" alt="image-20210221111759852" loading="lazy"></p>
<p>步骤：</p>
<pre class=" language-shell"><code class="language-shell"># 1、卸载旧的版本
yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine

# 2、需要的安装包
yum install -y yum-utils

# 3、设置镜像的仓库
yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo    # 默认是从国外的（太慢，不建议）


yum-config-manager \
    --add-repo \
    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 推荐使用阿里云的

# 4、更新软件包索引
yum makecache fast

# 5、安装docker相关的内容，docker-ce 社区版，ee 企业版
yum install docker-ce docker-ce-cli containerd.io

# 6、启动docker
systemctl start docker

# 7、查看是否安装成功
docker version</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221113029255.png" alt="image-20210221113029255" loading="lazy"></p>
<pre class=" language-shell"><code class="language-shell"># 8、使用run启动hello-word镜像
docker run hello-world</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221113237929.png" alt="image-20210221113237929" loading="lazy"></p>
<pre class=" language-shell"><code class="language-shell"># 9、查看一下下载的hello-world镜像是否存在
[root@iz2ze2js0u6m077omgcbzmz /]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB</code></pre>
<p>卸载docker：</p>
<pre class=" language-shell"><code class="language-shell"># 1、卸载依赖
yum remove docker-ce docker-ce-cli containerd.io

# 2、删除资源
rm -rf /var/lib/docker    # docker的默认工作路径</code></pre>
<h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p>1、访问阿里云控制台，找到<code>容器镜像服务</code></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221113956329.png" alt="image-20210221113956329" loading="lazy"></p>
<p>2、点击开通，设置仓库登录密码即可</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221114030975.png" alt="image-20210221114030975" loading="lazy"></p>
<p>3、找到镜像加速地址</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221114219761.png" alt="image-20210221114219761" loading="lazy"></p>
<p>4、配置使用</p>
<pre class=" language-shell"><code class="language-shell"># 创建目录
sudo mkdir -p /etc/docker

# 编写配置文件
sudo tee /etc/docker/daemon.json <<-'EOF'
{ 
  "registry-mirrors": ["https://keywishf.mirror.aliyuncs.com"]
} 
EOF

# 服务重启
sudo systemctl daemon-reload

# 启动doceker
sudo systemctl restart docker</code></pre>
<h3 id="回顾HelloWord流程"><a href="#回顾HelloWord流程" class="headerlink" title="回顾HelloWord流程"></a>回顾HelloWord流程</h3><p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221114717793.png" alt="image-20210221114717793" loading="lazy"></p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>Docker是怎么工作的？</strong></p>
<ul>
<li>Docker 是一个  client - Server 结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问！</li>
<li>DockerServer 接收到 Docker-client 的指令，就会执行这个命令！</li>
</ul>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221115243553.png" alt="image-20210221115243553" loading="lazy"></p>
<p><strong>Docker为什么比 VM（虚拟机）快？</strong></p>
<ol>
<li>Docker有着比虚拟机更少的抽象层</li>
<li>Docker利用的是宿主机的内核，vm需要的是 Guest OS</li>
</ol>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221115359405.png" alt="image-20210221115359405" loading="lazy"></p>
<p>所以说，新建一个容器的时候，<strong>docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。</strong>虚拟机加载 Guest OS，分钟级别的，而docker 是利用 宿主机的操作系统，省略了这个复杂的过程，秒级启动！</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221115710693.png" alt="image-20210221115710693" loading="lazy"></p>
<h2 id="3、Docker的常用命令"><a href="#3、Docker的常用命令" class="headerlink" title="3、Docker的常用命令"></a>3、Docker的常用命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><pre class=" language-shell"><code class="language-shell">docker version        # 像是docker的版本信息
docker info            # docker系统信息，包括镜像和容器的数量
docker 命令 --help   # 帮助命令</code></pre>
<p>帮助文档地址：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221120152725.png" alt="image-20210221120152725" loading="lazy"></p>
<h3 id="镜像的命令"><a href="#镜像的命令" class="headerlink" title="镜像的命令"></a>镜像的命令</h3><blockquote>
<p><strong>docker images</strong> ：查看本地所有镜像</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 查看镜像
[root@iz2ze2js0u6m077omgcbzmz /]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB

# 解释
REPOSITORY    镜像的仓库源
TAG            镜像的标签
IMAGE ID    镜像的id
CREATED        镜像的创建时间
SIZE        镜像的大小

# 常用的可选项
  -a, --all             # 列出所有的镜像
  -q, --quiet           # 只显示镜像的id</code></pre>
<blockquote>
<p>Docker search 搜索镜像</p>
</blockquote>
<p>可以直接在官网搜索镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221132848506.png" alt="image-20210221132848506" loading="lazy"></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221135305077.png" alt="image-20210221135305077" loading="lazy"></p>
<p>使用命令的方式：</p>
<pre class=" language-shell"><code class="language-shell">[root@iz2ze2js0u6m077omgcbzmz /]# docker search mysql
NAME        DESCRIPTION           STARS     OFFICIAL   AUTOMATED
mysql       MySQL is a widely used, open-source relation…   10530     [OK]       
mariadb     MariaDB is a community-developed fork of MyS…   3934      [OK]

# 可选项，通过收藏数来过滤（大于3000）
docker search mysql --filter=STARS=3000</code></pre>
<blockquote>
<p>docker pull 镜像下载</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 下载镜像 docker pull 镜像名[:tag]
[root@iz2ze2js0u6m077omgcbzmz /]# docker pull mysql
Using default tag: latest    # 不写tag，就默认下载最新版
latest: Pulling from library/mysql
a076a628af6f: Pull complete # 分层下载，docker images的核心，联合文件系统
f6c208f3f991: Pull complete 
88a9455a9165: Pull complete 
406c9b8427c6: Pull complete 
7c88599c0b25: Pull complete 
25b5c6debdaf: Pull complete 
43a5816f1617: Pull complete 
1a8c919e89bf: Pull complete 
9f3cf4bd1a07: Pull complete 
80539cea118d: Pull complete 
201b3cad54ce: Pull complete 
944ba37e1c06: Pull complete 
Digest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c    # 签名
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest    # 真实地址</code></pre>
<p>选择版本下载，必须对应官网中现有的版本</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221140220409.png" alt="image-20210221140220409" loading="lazy"></p>
<pre class=" language-shell"><code class="language-shell">[root@iz2ze2js0u6m077omgcbzmz /]# docker pull mysql:5.7
5.7: Pulling from library/mysql
a076a628af6f: Already exists # 不会重复下载现有东西
f6c208f3f991: Already exists 
88a9455a9165: Already exists 
406c9b8427c6: Already exists 
7c88599c0b25: Already exists 
25b5c6debdaf: Already exists 
43a5816f1617: Already exists 
1831ac1245f4: Pull complete 
37677b8c1f79: Pull complete 
27e4ac3b0f6e: Pull complete 
7227baa8c445: Pull complete 
Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808df
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221140501929.png" alt="image-20210221140501929" loading="lazy"></p>
<blockquote>
<p>docker rmi 删除镜像（通过id删除）</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 删除单个镜像
docker rmi -f 镜像id

# 删除多个镜像
docker rmi -f 镜像id 镜像id 镜像id 

# 删除全部镜像
docker rmi -f $(docker images -qp)    # -qp 是查询所有的id</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221140659054.png" alt="image-20210221140659054" loading="lazy"></p>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>说明：我们有了镜像才可以创建容器，Linux</p>
<pre class=" language-shell"><code class="language-shell">docker pull centos</code></pre>
<p>新建容器并启动</p>
<pre class=" language-shell"><code class="language-shell">docker run [可选参数] image

# 参数说明
--name="Name"    # 容器名字 tomcat01 tomcat 02, 用来区分容器
-d                # 后台方式运行
-it             # 使用交互方式运行，进入容器查看内容
-p                # 指定容器的端口 -p 8080:8080
    -p ip:主机端口:容器端口
    -p 主机端口:容器端口
    -p 容器端口
-P                # 随机指定端口（大写P）</code></pre>
<p><strong>启动并进入容器</strong></p>
<pre class=" language-shell"><code class="language-shell"># 使用-it交互模式，不然无法进入
[root@iz2ze2js0u6m077omgcbzmz /]# docker run -it centos /bin/bash

# 启动之后，发现主机名变化
# 查看的是容器内的centos文件
[root@afe08a58288f /]# ls
bin  etc   lib      lost+found  mnt  proc  run   srv  tmp  var
dev  home  lib64  media       opt  root  sbin  sys  usr

# 从容器中退回主机
[root@afe08a58288f /]# exit</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221142525271.png" alt="image-20210221142525271" loading="lazy"></p>
<p><strong>列出所有在运行的容器</strong></p>
<ul>
<li>-a ：列出当前正在运行的容器 + 历史运行过的容器</li>
<li>-n=?  ：显示最近创建的容器</li>
<li>-q ：只显示容器的编号</li>
</ul>
<pre class=" language-shell"><code class="language-shell"># 查看正在运行的容器，为空
[root@iz2ze2js0u6m077omgcbzmz /]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

# 查看曾经运行的容器
[root@iz2ze2js0u6m077omgcbzmz /]# docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                          PORTS     NAMES
afe08a58288f   centos         "/bin/bash"   3 minutes ago   Exited (0) About a minute ago             reverent_goldwasser
b4520ec7f5c1   bf756fb1ae65   "/hello"      3 hours ago     Exited (0) 3 hours ago                    youthful_margulis</code></pre>
<p><strong>退出容器</strong></p>
<pre class=" language-shell"><code class="language-shell">exit    # 直接容器停止并退出
Ctrl + p + Q    # 容器不停止退出</code></pre>
<p><strong>删除容器</strong></p>
<pre class=" language-shell"><code class="language-shell"># 删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f
docker rm 容器id    

# 删除所有的容器
docker rm -f $(docker ps -aq)

# 删除所有的容器
docker ps -a -q|xargs docker rm</code></pre>
<p><strong>启动和停止容器的操作</strong></p>
<pre class=" language-shell"><code class="language-shell"># 启动容器（对于启动之后停止的容器）
docker start 容器id

# 重启容器
docker restart 容器id

# 停止容器
docker stop 容器id

# 杀掉容器
docker kill 容器id</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210221144028836.png" alt="image-20210221144028836" loading="lazy"></p>
<h3 id="常用的其他命令"><a href="#常用的其他命令" class="headerlink" title="常用的其他命令"></a>常用的其他命令</h3><p><strong>后台启动容器</strong></p>
<pre class=" language-shell"><code class="language-shell"># 命令 docker run -d 镜像名
docker run -d centos

# 问题：执行docker ps 发现 centos 停止了

# 常见的坑：docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用就会自动停止
# nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</code></pre>
<pre class=" language-shell"><code class="language-shell"># 添加脚本启动
[root@iz2ze2js0u6m077omgcbzmz /]# docker run -d centos /bin/sh -c "while true;do echo helloworld;sleep 1;done"
5d09f7ecc0c2a3dddcb118607728baceceed3a0a1a36449432d7e96426055562

# 查看是否在运行
[root@iz2ze2js0u6m077omgcbzmz /]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
5d09f7ecc0c2   centos    "/bin/sh -c 'while t…"   4 seconds ago   Up 3 seconds             admiring_turing
</code></pre>
<p><strong>查看日志</strong></p>
<pre class=" language-shell"><code class="language-shell">docker logs -f -t --tail [条数] [容器id]

# 编写一段shell脚本
docker run -d centos /bin/sh -c "while true;do echo helloworld;sleep 1;done"

# 查看对应的日志，并不断追踪
-f # 日志带上时间戳
-t # 显示所有日志
[root@iz2ze2js0u6m077omgcbzmz /]# docker logs -f -t --tail 10 5d09f7ecc0c2</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222194426678.png" alt="image-20210222194426678" loading="lazy"></p>
<p><strong>查看容器的进程信息</strong></p>
<pre class=" language-shell"><code class="language-shell"># 命令：docker top 容器id（杀进程通过ppid）
[root@iz2ze2js0u6m077omgcbzmz /]# docker top 5d09f7ecc0c2
UID   PID    PPID      C      STIME    TTY        TIME         CMD
root   785   733       0      19:40    ?          00:00:00     /bin/sh -c while true;do echo helloworld;sleep 1;done

root   2081  785       0      19:46    ?          00:00:00    /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</code></pre>
<p><strong>查看镜像的元数据</strong></p>
<pre class=" language-shell"><code class="language-shell"># 命令： docker inspect 容器id
[root@iz2ze2js0u6m077omgcbzmz /]# docker inspect 5d09f7ecc0c2</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222195239209.png" alt="image-20210222195239209" loading="lazy"></p>
<p><strong>进入当前正在运行的容器</strong></p>
<pre class=" language-shell"><code class="language-shell"># 我们通常的容器都是使用后台方式进行，需要进入容器修改一些配置

# 方式一：docker exec -it 容器id /bin/bash
# 进入容器后开启一个新的终端，可以在里面操作（）常用

# 测试
[root@iz2ze2js0u6m077omgcbzmz /]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED             STATUS             PORTS     NAMES
5d09f7ecc0c2   centos    "/bin/sh -c 'while t…"   About an hour ago   Up About an hour             admiring_turing
[root@iz2ze2js0u6m077omgcbzmz /]# docker exec -it 5d09f7ecc0c2 /bin/bash
[root@5d09f7ecc0c2 /]# ls 
bin  etc   lib      lost+found  mnt  proc  run   srv  tmp  var
dev  home  lib64  media       opt  root  sbin  sys  usr</code></pre>
<pre class=" language-shell"><code class="language-shell"># 方式二：docker attach 容器id
# 进入容器正在执行的终端，不会启动新的进程</code></pre>
<p><strong>从容器内拷贝文件到主机上</strong></p>
<pre class=" language-shell"><code class="language-shell">docker cp 容器id：容器内路径 目的主机路径</code></pre>
<p>测试</p>
<pre class=" language-shell"><code class="language-shell"># 查看当前主机目录下
[root@iz2ze2js0u6m077omgcbzmz home]# ls
dst  epel-release-6-8.noarch.rpm  redis  www
[root@iz2ze2js0u6m077omgcbzmz home]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED             STATUS             PORTS     NAMES
5d09f7ecc0c2   centos    "/bin/sh -c 'while t…"   About an hour ago   Up About an hour             admiring_turing

# 进入docker容器内部
[root@iz2ze2js0u6m077omgcbzmz home]# docker exec -it 5d09f7ecc0c2 /bin/bash
[root@5d09f7ecc0c2 /]# cd home
[root@5d09f7ecc0c2 home]# ls
# 在容器中新建一个文件
[root@5d09f7ecc0c2 home]# touch test.java
# 退出容器
[root@5d09f7ecc0c2 home]# exit
exit

# 将这个文件拷贝出来到主机上
[root@iz2ze2js0u6m077omgcbzmz home]# docker cp 5d09f7ecc0c2:/home/test.java /home
[root@iz2ze2js0u6m077omgcbzmz home]# ls
dst  epel-release-6-8.noarch.rpm  redis  test.java  www

# 拷贝是一个手动过程，以后可以使用 -v 卷的技术，可以实现自动同步</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222211347895.png" alt="image-20210222211347895" loading="lazy"></p>
<h2 id="4、安装Nginx"><a href="#4、安装Nginx" class="headerlink" title="4、安装Nginx"></a>4、安装Nginx</h2><pre class=" language-shell"><code class="language-shell"># 1、搜索镜像（在官网中搜索才可以看到版本信息和文档）
docker search nginx

# 2、下载镜像
docker pull nginx

# 3、启动nginx
# -d 后台运行
# --name 给容器命名
# -p 宿主机端口：容器内部端口
docker run -d --name nginx01 -p 3344:80 nginx

# 4、测试访问端口
curl localhost:8000

# 5、停止nginx服务，停止之后就访问不了
docker stop 容器id/nginx01</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222213515808.png" alt="image-20210222213515808" loading="lazy"></p>
<p><strong>端口暴露原理：</strong>相当于主机的3344端口映射到docker中的80端口</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210222213117135.png" alt="image-20210222213117135" loading="lazy"></p>
<p>思考：我们每次要改动nginx的配置文件都需要进入容器内容，十分麻烦，是否可以在容器外部提供一个映射路径，达到在容器修改文件，容器内部就可以自动修改？</p>
<p>使用 -v 数据卷可以实现！</p>
<h2 id="5、安装Tomcat"><a href="#5、安装Tomcat" class="headerlink" title="5、安装Tomcat"></a>5、安装Tomcat</h2><pre class=" language-shell"><code class="language-shell"># 官方的使用
docker run -it --rm tomcat:9.0

# 我们之前的启动都是后台，停止容器之后，容器还是可以查到
# docker run -it --rm 一般用来测试，用完即删

# 1、下载启动
docker pull tomcat:9.0

# 2、启动运行
docker run -d -p 9000:8080 --name tomcat01 tomcat</code></pre>
<p>通过外网访问9000端口</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224114525865.png" alt="image-20210224114525865" loading="lazy"></p>
<p>分析出现404原因</p>
<pre class=" language-shell"><code class="language-shell"># 进入容器
docker exec -it tomcat01 /bin/bash

# 发现问题：1、linux命令少了，2、没有webapps
# 原因：阿里云镜像默认是最小的镜像，所有不必要的都剔除掉
# 保证最小可运行环境</code></pre>
<p>思考：以后要部署项目，每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，webapps我们可以在外部放置项目，就自动同步内部就好了！</p>
<h2 id="6、部署-ES-Kibana"><a href="#6、部署-ES-Kibana" class="headerlink" title="6、部署 ES + Kibana"></a>6、部署 ES + Kibana</h2><pre class=" language-shell"><code class="language-shell"># es 暴露的端口很多
# es 十分的耗内存 1.x G
# es 的数据一般需要放置到安全目录！挂载
# --net somenetwork 为网络配置，暂时不用

# 下载启动 elasticsearch
docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2

# 启动了之后 linux 就会卡住了！ docker stats 查看cpu状态

# 查看 docker stats

# 测试以下es是否成功了
curl localhost:9200

# 赶紧关闭，增加内容的限制
docker stop 容器id</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224120856019.png" alt="image-20210224120856019" loading="lazy"></p>
<blockquote>
<p>修改配置文件 -e 环境配置修改</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 修改配置文件，限制使用的内容
docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node"  -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2

# 查看docker stats
docker stats 容器id</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224120905711.png" alt="image-20210224120905711" loading="lazy"></p>
<blockquote>
<p>使用kibana连接ES</p>
</blockquote>
<p>思考网络如何连接过去</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224121140385.png" alt="image-20210224121140385" loading="lazy"></p>
<h2 id="7、可视化"><a href="#7、可视化" class="headerlink" title="7、可视化"></a>7、可视化</h2><p><strong>portainer（先用这个）</strong></p>
<pre class=" language-shell"><code class="language-shell">docker run -d -p 8088:9000 \
--restart=always -v "/var/run/docker.sock:/var/run/docker.sock" --privileged=true portainer/portainer</code></pre>
<p><strong>Rancher（CI/CD再用）</strong></p>
<blockquote>
<p>什么是 portainer？</p>
</blockquote>
<p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p>
<pre class=" language-shell"><code class="language-shell"># 下载portainer
docker run -d -p 8088:9000 \
--restart=always -v "/var/run/docker.sock:/var/run/docker.sock" --privileged=true portainer/portainer</code></pre>
<p>访问测试：外网8088</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224125709788.png" alt="image-20210224125709788" loading="lazy"></p>
<p>首次加载比较久，设置用户名密码之后进入</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224130039423.png" alt="image-20210224130039423" loading="lazy"></p>
<p>选择使用本地仓库</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224130152827.png" alt="image-20210224130152827" loading="lazy"></p>
<p>连接进入</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224130838730.png" alt="image-20210224130838730" loading="lazy"></p>
<p>这里可以查看所有的镜像和容器</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224130930288.png" alt="image-20210224130930288" loading="lazy"></p>
<h2 id="8、Docker镜像讲解"><a href="#8、Docker镜像讲解" class="headerlink" title="8、Docker镜像讲解"></a>8、Docker镜像讲解</h2><h3 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时，库、环境变量和配置文件。</p>
<p>所有的应用，直接打包成为docker镜像，就可以直接跑起来！</p>
<p><strong>如何得到镜像：</strong></p>
<ul>
<li>从远程仓库下载</li>
<li>朋友拷贝给你</li>
<li>自己制作一个镜像 DockerFile</li>
</ul>
<h3 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h3><blockquote>
<p>UnionFS（联合文件系统）</p>
</blockquote>
<p>UnionFS（联合文件系统）：是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以<strong>将不同目录挂载到同一个虚拟文件系统下</strong>。Union 文件系统是 Docker 镜像的基础。镜像而可以通过分层来进行继承，基于镜像基础（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>例如：</p>
<pre class=" language-shell"><code class="language-shell"># 安装docker   第一层
# 安装centos     第二层
# 安装JDK         第三层</code></pre>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与外面典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由cootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs（root file system），在bootfs之上。包含的就是典型Linux系统中的/dev，/proc，/bin，/etc 等标准目录和文件。rootfs就是各种不同操作系统发行版，比如Ubuntu，Centos等。</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224141840002.png" alt="image-20210224141840002" loading="lazy"></p>
<p>平时我们安装进虚拟机的Centos都是好几个G，为什么Docker这里才200M？</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210224141943651.png" alt="image-20210224141943651" loading="lazy"></p>
<p>对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见，对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。</p>
<h3 id="分层原理"><a href="#分层原理" class="headerlink" title="分层原理"></a>分层原理</h3><blockquote>
<p>分层的镜像</p>
</blockquote>
<p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的下载！</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313095405902.png" alt="image-20210313095405902" loading="lazy"></p>
<p>思考：为什么docker镜像要采用这种分层的结构呢？</p>
<p>最大的好处，莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需要在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享！</p>
<p>查看镜像封层的方式可以通过 docker image inspect 命令</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@iz2ze2js0u6m077omgcbzmz ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker image inspect redis:latest</span></code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313095817664.png" alt="image-20210313095817664" loading="lazy"></p>
<p><strong>理解：</strong></p>
<p>所有的Docker 镜像都始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
<p>举一个简单的例子，例如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在这个镜像中添加 Python 包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p>
<p>该镜像当前已经包含3个镜像层，如下图所示（简单的例子）</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313100226470.png" alt="image-20210313100226470" loading="lazy"></p>
<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。如下图，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313100636010.png" alt="image-20210313100636010" loading="lazy"></p>
<p>上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。</p>
<p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层的文件7 是文件5的一个更新版本（可以覆盖文件5）。</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313100828231.png" alt="image-20210313100828231" loading="lazy"></p>
<p>在这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p>
<p><strong>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈</strong>，并保证多镜像层对外展示为统一的文件系统。</p>
<p>Linux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p>
<p>Docker 在 Windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS 文件系统之上实现了分层和 Cow。</p>
<p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313101426464.png" alt="image-20210313101426464" loading="lazy"></p>
<blockquote>
<p>特点</p>
</blockquote>
<p>Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层（无法改变）！</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313102020837.png" alt="image-20210313102020837" loading="lazy"></p>
<p>完整过程：</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313102242966.png" alt="image-20210313102242966" loading="lazy"></p>
<h2 id="9、commit容器"><a href="#9、commit容器" class="headerlink" title="9、commit容器"></a>9、commit容器</h2><blockquote>
<p>提交镜像</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash">docker commit 提交容器成为一个新的副本

<span class="token comment" spellcheck="true"># 命令和 git 原理类似</span>
docker commit -m<span class="token operator">=</span><span class="token string">"提交的描述信息"</span> -a<span class="token operator">=</span><span class="token string">"作者"</span> 容器id 目标镜像名：<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span></code></pre>
<p>实战测试</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1、启动一个默认的tomcat</span>
<span class="token punctuation">[</span>root@iz2ze2js0u6m077omgcbzmz ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it -p 9000:8080 tomcat</span>

<span class="token comment" spellcheck="true"># 2、发现这个默认的 tomcat 是没有webapps应用。这是镜像的原因，官方的镜像默认 webapps下面是没有文件的！</span>
<span class="token punctuation">[</span>root@iz2ze2js0u6m077omgcbzmz ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker exec -it fc6993915d41 /bin/bash</span>

<span class="token comment" spellcheck="true"># 3、自行拷贝进去了基本文件</span>
root@fc6993915d41:/usr/local/tomcat<span class="token comment" spellcheck="true"># cp -r webapps.dist/* webapps</span>
root@fc6993915d41:/usr/local/tomcat<span class="token comment" spellcheck="true"># cd webapps</span>
root@fc6993915d41:/usr/local/tomcat/webapps<span class="token comment" spellcheck="true"># ls</span>
ROOT  docs  examples  host-manager  manager</code></pre>
<p>修改之后就可以看到正常的tomcat页面了</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313104046775.png" alt="image-20210313104046775" loading="lazy"></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 4、将我们操作过的容器通过 commit 提交为一个镜像！我们以后就使用修改过的镜像即可，自定义为tomcat02，版本为1.0</span>
<span class="token punctuation">[</span>root@iz2ze2js0u6m077omgcbzmz ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker commit -a="xiaojiang" -m="add webapps app" fc6993915d41 tomcat02:1.0</span></code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313104432119.png" alt="image-20210313104432119" loading="lazy"></p>
<p>如果想要保存当前容器的状态，就可以通过commit 来提交，获得一个镜像，就好比我们以前学习VM时候使用的快照。</p>
<h2 id="10、容器数据卷"><a href="#10、容器数据卷" class="headerlink" title="10、容器数据卷"></a>10、容器数据卷</h2><h3 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h3><p><strong>docker的理论回顾</strong></p>
<p>将应用和环境打包成一个镜像！</p>
<p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p>
<p>MySQL，容器删了，数据也没了！需求：MySQL数据可以存储在本地！</p>
<p>容器之间可以有一个数据共享技术！Docker容器中产生的数据，同步到本地！</p>
<p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210313105411779.png" alt="image-20210313105411779" loading="lazy"></p>
<p><strong>总结：容器的持久化和同步操作！容器间也可以数据共享！</strong></p>
<h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><blockquote>
<p>方式一：直接使用命令来挂载 -v</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 就好比端口映射
docker run -it -v 主机目录：容器内目录

# 测试
docker run -it -v /home/ceshi:/home centos /bin/bash

# 启动起来之后我们可以通过 docker inspect 容器id （进行查看）
docker inspect bb59516980a9</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320163453833.png" alt="image-20210320163453833" loading="lazy"></p>
<p>测试文件的同步</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320163735466.png" alt="image-20210320163735466" loading="lazy"></p>
<p><strong>测试：停止容器之后修改文件</strong></p>
<ol>
<li>停止容器</li>
<li>宿主机上修改文件</li>
<li>启动容器</li>
<li>容器内的数据内容依然存在</li>
</ol>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320164253752.png" alt="image-20210320164253752" loading="lazy"></p>
<p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p>
<h3 id="实战：安装MySQL"><a href="#实战：安装MySQL" class="headerlink" title="实战：安装MySQL"></a>实战：安装MySQL</h3><p>思考：MySQL 的数据持久化问题！</p>
<pre class=" language-shell"><code class="language-shell"># 获取镜像
docker pull mysql:5.7

# 运行容器，需要做数据挂载
# 注意：安装启动mysql，需要配置密码的
# 官方测试：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

# 启动我们的
# -d 后台运行
# -p 端口映射
# -v 卷挂载
# -e 环境配置
# --name 容器名字

docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d --name mysql01 mysql:5.7</code></pre>
<p>启动成功之后，我们使用本地的软件navicat来测试连接</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320170918960.png" alt="image-20210320170918960" loading="lazy"></p>
<pre class=" language-shell"><code class="language-shell"># 连接原理：
# navicat - 连接到服务器的3310 --- 3310 和容器内的 3306 映射，这个时候我们就可以连接上了（注意开放3310端口）</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210320171116706.png" alt="image-20210320171116706" loading="lazy"></p>
<blockquote>
<p>测试</p>
</blockquote>
<ol>
<li><p>在本地连接Mysql并创建数据库</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323104917217.png" alt="image-20210323104917217" loading="lazy"></p>
</li>
<li><p>发现服务器目录下同样也多出了这个文件</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323105001667.png" alt="image-20210323105001667" loading="lazy"></p>
</li>
<li><p>所以就算把mysql容器删除了，但是我们挂载在本地的数据卷并不会丢失！</p>
</li>
</ol>
<h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><blockquote>
<p>匿名挂载</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 匿名挂载，-P随机映射端口
-v 容器内路径！
docker run -d -P --name nginx01 -v /etc/nginx nginx

# 查看所有的卷的情况
docker volume ls

# 这里发现，这种就是匿名挂载，我们在 -v 只写了容器内的路径，没有写容器外的路径</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323105853180.png" alt="image-20210323105853180" loading="lazy"></p>
<blockquote>
<p>具名挂载</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 具名挂载
docker run -d -P --name nginx02 -v juming:/etc/nginx nginx

# 查看所有的卷的情况
docker volume ls</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323110159402.png" alt="image-20210323110159402" loading="lazy"></p>
<blockquote>
<p>查看挂载的信息和目录</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 查看这个卷
docker volume inspect juming-nginx</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323110527647.png" alt="image-20210323110527647" loading="lazy"></p>
<p>所有的docker容器内的卷，没有指定目录的情况下都是在<code>/var/lib/docker/volumes</code>目录下。</p>
<p>我们通过具名挂载可以方便的找到我们的一个卷，大多数情况使用的<code>具名挂载</code></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323110709008.png" alt="image-20210323110709008" loading="lazy"></p>
<blockquote>
<p>查看nginx的配置文件</p>
</blockquote>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323110900556.png" alt="image-20210323110900556" loading="lazy"></p>
<blockquote>
<p>确定是具名挂载还是匿名挂载，还是指定路径挂载</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">-v 容器内路径               # 匿名挂载
-v 卷名：容器内路径             # 具名挂载
-v /宿主机路径:/容器内路径    # 指定路径挂载</code></pre>
<p><strong>拓展：</strong></p>
<pre class=" language-shell"><code class="language-shell"># 通过 -v 容器内路径:ro    rw 改变读写权限
ro    readonly    # 只读
rw    readwrite    # 可读写

# 一旦设置了容器的权限，容器对我们挂载出来的内容就有限定了！
docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx

# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部无法操作！</code></pre>
<h3 id="初识-Dockersfile"><a href="#初识-Dockersfile" class="headerlink" title="初识 Dockersfile"></a>初识 Dockersfile</h3><p>Dockerfile 就是用来构建 docker 镜像的构建文件！命令脚本！</p>
<p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个一个的命令，每个命令就是一层！</p>
<pre class=" language-shell"><code class="language-shell"># 创建一个dockerfile文件
cd /home

mkdir docker-test-volume

cd docker-test-volume/
vim dockerfile01

# 编写文件内容，的hi零都是大写的，匿名挂载
FROM centos

VOLUME ["volume01", "volume02"]

CMD echo "-----end-----"
CMD /bin/bash</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323123800056.png" alt="image-20210323123800056" loading="lazy"></p>
<blockquote>
<p>生成镜像</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># -f 指定dockerfile文件
# -t 命名镜像
# . 表示在当前路径下生成

docker build -f dockerfile01 -t xiaojiang/centos:1.0 .</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323124140288.png" alt="image-20210323124140288" loading="lazy"></p>
<p>查看镜像</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323124211684.png" alt="image-20210323124211684" loading="lazy"></p>
<blockquote>
<p>启动自己写的容器</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 启动容器
docker run -it 49a93c8bcf07

# 查看容器文件
ls -l</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323124453637.png" alt="image-20210323124453637" loading="lazy"></p>
<p>这个卷和外部一定有一个同步的目录，我们在上方使用了匿名挂载</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323124542728.png" alt="image-20210323124542728" loading="lazy"></p>
<pre class=" language-shell"><code class="language-shell"># 查看卷挂载的路径
docker inspect 6e56e2421de7</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323125156803.png" alt="image-20210323125156803" loading="lazy"></p>
<p>这种方式我们未来使用的十分多，因为我们通常回构建自己的镜像！</p>
<p>假设构建镜像的时候没有挂载卷，要手动镜像挂载 <code>-v 卷名 容器内路径</code></p>
<h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>两个 MySQL 同步数据</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323125814307.png" alt="image-20210323125814307" loading="lazy"></p>
<blockquote>
<p>测试多个容器共享数据</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 启动容器1
docker run -it --name docker01 xiaojiang/centos:1.0
# 按 ctrl + P + Q 退出界面

# 启动容器2并挂载上容器1
docker run -it --name docker02 --volumes-from docker01 xiaojiang/centos:1.0

# 进入docker01容器，编写共享文件
docker attach d3261b8b1c70
cd volumes01
touch docker01

# 在docker02容器中查看</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323131445769.png" alt="image-20210323131445769" loading="lazy"></p>
<pre class=" language-shell"><code class="language-shell"># 创建容器3，挂载到容器2
docker run -it --name docker03 --volumes-from docker01 xiaojiang/centos:1.0</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323131633410.png" alt="image-20210323131633410" loading="lazy"></p>
<pre class=" language-shell"><code class="language-shell"># 在docker03中编写文件，发现在其他容器中同样可以查看到
touch docker03</code></pre>
<pre class=" language-shell"><code class="language-shell"># 将容器1删除，查看是否回产生影响
docker rm -f docker01</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323132106770.png" alt="image-20210323132106770" loading="lazy"></p>
<p>发现数据依然存在</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20210323132149674.png" alt="image-20210323132149674" loading="lazy"></p>
<blockquote>
<p>多个mysql实现数据共享</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 启动一个mysql01
docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7

# 启动mysql02
docker run -d -p 3311:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7

# 这个时候就可以实现两个容器数据同步！</code></pre>
<p>结论：</p>
<p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p>
<p>一旦持久化到了本地，这个时候本地的数据是不会删除的！</p>
<h2 id="11、DockerFile"><a href="#11、DockerFile" class="headerlink" title="11、DockerFile"></a>11、DockerFile</h2><h3 id="DockerFile-介绍"><a href="#DockerFile-介绍" class="headerlink" title="DockerFile 介绍"></a>DockerFile 介绍</h3><p>dockerfile 是用来构建 docker 镜像的文件，命令参数脚本</p>
<p>构建步骤：</p>
<ol>
<li>编写一个 dockerfile 文件</li>
<li>docker build 构建成为一个镜像</li>
<li>docker run 运行镜像</li>
<li>docker push 发布镜像（DockerHub、阿里云镜像仓库）</li>
</ol>
<p>查看一下官方用法，访问 <a target="_blank" rel="noopener" href="https://hub.docker.com/%EF%BC%8C%E6%90%9C%E7%B4%A2centos%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%8B%E6%96%B9%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E5%8D%B3%E5%8F%AF%E8%B7%B3%E8%BD%AC%E5%88%B0%E5%AF%B9%E5%BA%94">https://hub.docker.com/，搜索centos，点击下方版本信息即可跳转到对应</a> GitHub 仓库查看源码</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220527225921014.png" alt="image-20220527225921014" loading="lazy"></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220527230035128.png" alt="image-20220527230035128" loading="lazy"></p>
<p>但是很多官方镜像都是基础包，很多功能没有，通常需要我们自己搭建镜像！</p>
<h3 id="DockerFile-构建过程"><a href="#DockerFile-构建过程" class="headerlink" title="DockerFile 构建过程"></a>DockerFile 构建过程</h3><blockquote>
<p>基础知识</p>
</blockquote>
<ol>
<li><p>每个保留关键字（指令）都是必须大写字母</p>
</li>
<li><p>执行顺序为从上到下</p>
</li>
<li><p><code>#</code>表示注释</p>
</li>
<li><p>每一个指令都会创建提交一个新的镜像层，并提交</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220527231105839.png" alt="image-20220527231105839" loading="lazy"></p>
</li>
</ol>
<p>dockerfile 是面向开发的，我们以后要发布项目，做镜像，就需要编写 dockerfile 文件。</p>
<blockquote>
<p>步骤</p>
</blockquote>
<p>DockerFile：构建文件，定义一切的步骤，源代码</p>
<p>Docker镜像：通过 DockerFile 构建生成的镜像，最终发布和运行的产品</p>
<p>Docker容器：容器就是镜像运行起来提供服务</p>
<h3 id="DockerFile-指令"><a href="#DockerFile-指令" class="headerlink" title="DockerFile 指令"></a>DockerFile 指令</h3><p>可以通过以下指令，构建自己的镜像</p>
<pre class=" language-bash"><code class="language-bash">FROM            <span class="token comment" spellcheck="true"># 基础镜像，一切从这里开始构建</span>
MAINTAINER        <span class="token comment" spellcheck="true"># 镜像是谁写的，姓名 + 邮箱</span>
RUN                <span class="token comment" spellcheck="true"># 惊醒构建的时候需要运行的命令</span>
ADD                <span class="token comment" spellcheck="true"># 添加其他内容要这个镜像中</span>
WORKDIKR        <span class="token comment" spellcheck="true"># 镜像的工作目录</span>
VOLUME            <span class="token comment" spellcheck="true"># 挂载的目录，-v</span>
EXPOSE            <span class="token comment" spellcheck="true"># 保留端口配置，-p</span>
CMD                <span class="token comment" spellcheck="true"># 指定这个容器启动的时候要运行的命令，只有最后一个生效</span>
ENTRYPOINT        <span class="token comment" spellcheck="true"># 指定这个容器启动的时候要运行的命令，可以追加命令</span>
ONBUILD            <span class="token comment" spellcheck="true"># 当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令</span>
COPY            <span class="token comment" spellcheck="true"># 类似ADD，将我们的文件拷贝到镜像中</span>
ENV                <span class="token comment" spellcheck="true"># 构建的时候设置环境变量，-e</span></code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220528103602675.png" alt="image-20220528103602675" loading="lazy"></p>
<h3 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h3><blockquote>
<p>基础镜像</p>
</blockquote>
<p>Docker Hub 中大部分镜像都是从这个基础镜像过来的 FROM scratch，然后配置需要的软件和配置来进行构建</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220528124707258.png" alt="image-20220528124707258" loading="lazy"></p>
<blockquote>
<p>创建一个自己的centos</p>
</blockquote>
<p>1、编写 DockerFile 文件</p>
<pre class=" language-bash"><code class="language-bash">vim mydockerfile-centos

FROM centos
MAINTAINER luxiaojiang<span class="token operator">&lt;</span>1256240778@qq.com<span class="token operator">></span>

ENV MYPATH /usr/local
WORKDIR <span class="token variable">$MYPATH</span>

RUN yum -y <span class="token function">install</span> vim
RUN yum -y <span class="token function">install</span> net-tools

EXPOSE 80

CMD <span class="token keyword">echo</span> <span class="token variable">$MYPATH</span>
CMD <span class="token keyword">echo</span> <span class="token string">"----end----"</span>
CMD /bin/bash</code></pre>
<p>2、通过这个文件构建镜像</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 命令 docker build -f dockerfile -t 镜像名:[tag] [文件路径]</span>
docker build -f mydockerfile-centos -t mycentos:1.0 <span class="token keyword">.</span></code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220528132801081.png" alt="image-20220528132801081" loading="lazy"></p>
<p>报错了：The command ‘/bin/sh -c yum -y install vim’ returned a non-zero code: 1</p>
<p>原因：docker中的centos版本对应不上，需要设置版本，宿主机上的centos是7</p>
<pre class=" language-bash"><code class="language-bash">FROM centos:7</code></pre>
<p>修改好版本之后即可</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220528134158091.png" alt="image-20220528134158091" loading="lazy"></p>
<p>3、运行镜像</p>
<pre class=" language-bash"><code class="language-bash">docker run -it mycentos:1.0</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220529004715495.png" alt="image-20220529004715495" loading="lazy"></p>
<p>此时可以发现直接进入到工作目录，这是编写 dockerfile 文件的时候设置的</p>
<p>并且发现 ifconfig 和 vim 指令也可以使用了</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220529004942637.png" alt="image-20220529004942637" loading="lazy"></p>
<blockquote>
<p>查看镜像的变更历史</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># docker history [镜像id]</span>
docker <span class="token function">history</span> af69beb2f34e</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220529005138938.png" alt="image-20220529005138938" loading="lazy"></p>
<blockquote>
<p>CMD 和 ENTRYPOINT 区别</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash">CMD            <span class="token comment" spellcheck="true"># 指定容器启动的时候要运行的命令，只有最后一个生效，最后一个替换此前的命令</span>
ENTRYPOINT    <span class="token comment" spellcheck="true"># 指定容器启动的时候要运行的命令，可以不断追加命令指令</span></code></pre>
<p><strong>CMD测试</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建 dockerfile 文件</span>
vim dockerfile-cmd-test
FROM centos
CMD <span class="token punctuation">[</span><span class="token string">"ls"</span>, <span class="token string">"-a"</span><span class="token punctuation">]</span>

<span class="token comment" spellcheck="true"># 生成镜像</span>
docekr build -f dockerfile-cmd-test -t cmdtest:1.0 <span class="token keyword">.</span>

<span class="token comment" spellcheck="true"># 运行镜像</span>
docker run 96ea83f47d80
<span class="token keyword">.</span>
<span class="token punctuation">..</span>
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

<span class="token comment" spellcheck="true"># 测试追加命令</span>
docker run 96ea83f47d80 -l 
docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: <span class="token string">"-l"</span><span class="token keyword">:</span> executable <span class="token function">file</span> not found <span class="token keyword">in</span> <span class="token variable">$PATH</span><span class="token keyword">:</span> unknown.
ERRO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> error waiting <span class="token keyword">for</span> container: context canceled </code></pre>
<p><strong>ENTRYPOINT测试</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建 dockerfile 文件</span>
vim dockerfile-entrypoint-test
FROM centos
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"ls"</span>, <span class="token string">"-a"</span><span class="token punctuation">]</span>

<span class="token comment" spellcheck="true"># 生成镜像</span>
docker build -f dockerfile-entrypoint-test -t entrypoint-test:1.0 <span class="token keyword">.</span>

<span class="token comment" spellcheck="true"># 执行镜像</span>
docker run de9251f23f04
<span class="token keyword">.</span>
<span class="token punctuation">..</span>
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

<span class="token comment" spellcheck="true"># 追加命令测试</span>
docker run de9251f23f04 -l
total 56
drwxr-xr-x   1 root root 4096 May 29 14:00 <span class="token keyword">.</span>
drwxr-xr-x   1 root root 4096 May 29 14:00 <span class="token punctuation">..</span>
-rwxr-xr-x   1 root root    0 May 29 14:00 .dockerenv
lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -<span class="token operator">></span> usr/bin
drwxr-xr-x   5 root root  340 May 29 14:00 dev
drwxr-xr-x   1 root root 4096 May 29 14:00 etc
drwxr-xr-x   2 root root 4096 Nov  3  2020 home
lrwxrwxrwx   1 root root    7 Nov  3  2020 lib -<span class="token operator">></span> usr/lib
lrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -<span class="token operator">></span> usr/lib64
drwx------   2 root root 4096 Sep 15  2021 lost+found
drwxr-xr-x   2 root root 4096 Nov  3  2020 media
drwxr-xr-x   2 root root 4096 Nov  3  2020 mnt
drwxr-xr-x   2 root root 4096 Nov  3  2020 opt
dr-xr-xr-x 114 root root    0 May 29 14:00 proc
dr-xr-x---   2 root root 4096 Sep 15  2021 root
drwxr-xr-x  11 root root 4096 Sep 15  2021 run
lrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -<span class="token operator">></span> usr/sbin
drwxr-xr-x   2 root root 4096 Nov  3  2020 srv
dr-xr-xr-x  13 root root    0 May 29 14:00 sys
drwxrwxrwt   7 root root 4096 Sep 15  2021 tmp
drwxr-xr-x  12 root root 4096 Sep 15  2021 usr
drwxr-xr-x  20 root root 4096 Sep 15  2021 var</code></pre>
<h3 id="制作-Tomcat-镜像"><a href="#制作-Tomcat-镜像" class="headerlink" title="制作 Tomcat 镜像"></a>制作 Tomcat 镜像</h3><p> 1、准备镜像文件 tomcat 压缩包，jdk 的压缩包</p>
<p>下载jdk：<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531200714897.png" alt="image-20220531200714897" loading="lazy"></p>
<p>下载tomcat：<a target="_blank" rel="noopener" href="https://tomcat.apache.org/download-90.cgi">https://tomcat.apache.org/download-90.cgi</a></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531200649800.png" alt="image-20220531200649800" loading="lazy"></p>
<p>上传至服务器</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531203510027.png" alt="image-20220531203510027" loading="lazy"></p>
<p>2、编写 dockerfile 文件，官方命名 <code>Dockerfile</code>，构建镜像的时候 build 会自动寻找这个文件，就不需要 -f 指定了</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建文件</span>
<span class="token function">touch</span> redme.txt

<span class="token comment" spellcheck="true"># 编写 dockerfile</span>
<span class="token comment" spellcheck="true"># COPY 用于直接复制文件</span>
<span class="token comment" spellcheck="true"># ADD 会添加并解压</span>
vim Dockerfile

FROM centos:7
MAINTAINER luxiaojiang<span class="token operator">&lt;</span>1256240778@qq.com<span class="token operator">></span>

COPY readme.txt /usr/local/readme.txt

ADD jdk-8u333-linux-x64.tar.gz /usr/local/
ADD apache-tomcat-9.0.63.tar.gz /usr/local/

RUN yum -y <span class="token function">install</span> vim

ENV MYPATH /usr/local
WORKDIR <span class="token variable">$MYPATH</span>

ENV JAVA_HOME /usr/local/jdk1.8.0_333
ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.63
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.63

ENV PATH <span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token variable">$CATALINA_HOME</span>/lib:<span class="token variable">$CATALINA_HOME</span>/bin

EXPOSE 8080

CMD <span class="token variable">$CATALINA_HOME</span>/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> -F <span class="token variable">$CATALINE_HOME</span>/bin/logs/catalina.out</code></pre>
<p>3、构建镜像</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 因为文件直接命令为 Dockerfile，所以不需要加 -f 命令</span>
docker build -t luxiaojiang123/diytomcat:1.0 <span class="token keyword">.</span></code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531205805983.png" alt="image-20220531205805983" loading="lazy"></p>
<p>4、运行镜像</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -d 后台运行</span>
<span class="token comment" spellcheck="true"># -p 指定端口映射</span>
<span class="token comment" spellcheck="true"># --name 设置容器名称</span>
<span class="token comment" spellcheck="true"># -v 挂在目录</span>
docker run -d -p 9000:8080 --name lxjtomcat -v /usr/local/docker/tomcat/test:/usr/local/apache-tomcat-9.0.63/webapps/test -v /usr/local/docker/tomcat/logs:/usr/local/apache-tomcat-9.0.63/logs luxiaojiang123/diytomcat</code></pre>
<p>5、进入容器</p>
<pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it acea24c093fd /bin/bash</code></pre>
<p>6、退出容器，测试访问</p>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">exit</span> 

<span class="token comment" spellcheck="true"># 在宿主机访问测试</span>
curl localhost:9000</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220531222907177.png" alt="image-20220531222907177" loading="lazy"></p>
<p>7、测试目录挂载</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入容器</span>
docker <span class="token function">exec</span> -it 775e83020e9b /bin/bash
<span class="token function">cd</span> /usr/local/apache-tomcat-9.0.63/webapps/test</code></pre>
<p>8、在宿主机创建 jsp 文件</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/docker/tomcat/test
vim index.jsp</code></pre>
<pre class=" language-html"><code class="language-html">&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>hello,luxiaojiang<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
        hello, world! <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span>
           <span class="token attr-name">System.out.println("----my</span> <span class="token attr-name">test</span> <span class="token attr-name">web</span> <span class="token attr-name">logs-----");</span>
         <span class="token attr-name">%</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>9、可以查看到容器内的挂载目录也新增了一个文件</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220601110737543.png" alt="image-20220601110737543" loading="lazy"></p>
<p>10、访问测试</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220601113502498.png" alt="image-20220601113502498" loading="lazy"></p>
<p>项目部署成功之后就可以直接访问了</p>
<p>以后的开发步骤：需要掌握 Dockerfile 的编写！我们之后的一切都是使用 docker 镜像来发布运行！</p>
<h3 id="发布到-DockerHub"><a href="#发布到-DockerHub" class="headerlink" title="发布到 DockerHub"></a>发布到 DockerHub</h3><blockquote>
<p>DockerHub</p>
</blockquote>
<p>1、地址：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220601113611511.png" alt="image-20220601113611511" loading="lazy"></p>
<p>2、注册完账号之后直接在服务器上进行登录</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>base<span class="token punctuation">)</span> ?  tomcat docker login --help

Usage:  docker login <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> <span class="token punctuation">[</span>SERVER<span class="token punctuation">]</span>

Log <span class="token keyword">in</span> to a Docker registry.
If no server is specified, the default is defined by the daemon.

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username</code></pre>
<p>3、登录完成之后直接提交就行</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220601114205873.png" alt="image-20220601114205873" loading="lazy"></p>
<p>4、提交镜像</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># docker push [用户名]/[镜像名]</span>
docker push luxiaojiang123/diytomcat</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220602003144618.png" alt="image-20220602003144618" loading="lazy"></p>
<p>5、登录 DockerHub 查看是否上传成功</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220602003226575.png" alt="image-20220602003226575" loading="lazy"></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220602003505172.png" alt="image-20220602003505172" loading="lazy"></p>
<h3 id="发布到阿里云"><a href="#发布到阿里云" class="headerlink" title="发布到阿里云"></a>发布到阿里云</h3><p>1、登录阿里云</p>
<p>2、找到容器镜像服务</p>
<p>3、创建命名空间</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603145510984.png" alt="image-20220603145510984" loading="lazy"></p>
<p>4、创建镜像仓库</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603145555686.png" alt="image-20220603145555686" loading="lazy"></p>
<p>选择本地仓库</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603145657292.png" alt="image-20220603145657292" loading="lazy"></p>
<p>就可以看到相应的操作指南了</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603150044156.png" alt="image-20220603150044156" loading="lazy"></p>
<p>5、测试</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进行登录</span>
docker login --username<span class="token operator">=</span>晓江233 registry.cn-shenzhen.aliyuncs.com</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603150306528.png" alt="image-20220603150306528" loading="lazy"></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 重新构建镜像，命名为 [用户名]/[镜像名]</span>
docker build -t registry.cn-shenzhen.aliyuncs.com/luxiaojiang/diytomcat:1.0 <span class="token keyword">.</span>

<span class="token comment" spellcheck="true"># 也可以直接重命名本地镜像名称，并生成相应副本（不是修改原镜像）</span>
docker tag <span class="token punctuation">[</span>镜像id<span class="token punctuation">]</span> <span class="token punctuation">[</span>仓库名<span class="token punctuation">]</span>:<span class="token punctuation">[</span>版本<span class="token punctuation">]</span></code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603160708922.png" alt="image-20220603160708922" loading="lazy"></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 推送镜像到阿里云</span>
docker push registry.cn-shenzhen.aliyuncs.com/luxiaojiang/diytomcat:1.0</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603151515840.png" alt="image-20220603151515840" loading="lazy"></p>
<p>上传成功之后就可以在阿里云中查看到对应的镜像了</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603155939355.png" alt="image-20220603155939355" loading="lazy"></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603154239954.png" alt="image-20220603154239954" loading="lazy"></p>
<h2 id="12、Docker网络"><a href="#12、Docker网络" class="headerlink" title="12、Docker网络"></a>12、Docker网络</h2><h3 id="Docker0"><a href="#Docker0" class="headerlink" title="Docker0"></a>Docker0</h3><blockquote>
<p>测试</p>
</blockquote>
<p>1、获取 docker 的 ip 地址</p>
<pre class=" language-bash"><code class="language-bash">ip addr</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220603230617079.png" alt="image-20220603230617079" loading="lazy"></p>
<p>问题：docker 是如何处理容器网络访问的？</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604000636559.png" alt="image-20220604000636559" loading="lazy"></p>
<p>2、启动 tomcat 容器</p>
<pre class=" language-bash"><code class="language-bash">docker run -d -P --name tomcat01 tomcat</code></pre>
<p>3、查看容器的 ip 地址</p>
<pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it tomcat01 ip addr</code></pre>
<p>报错：OCI runtime exec failed: exec failed: unable to start container process: exec: “ip”: executable file not found in $PATH: unknown</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604001705002.png" alt="image-20220604001705002" loading="lazy"></p>
<p>解决：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 执行以下命令</span>
apt update <span class="token operator">&amp;&amp;</span> apt <span class="token function">install</span> -y iproute2</code></pre>
<p>4、发现容器启动的时候会得到一个 eth0 ip地址，这是 docker 分配的，并且可以直接 ping 通 docker 容器内部</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604002118769.png" alt="image-20220604002118769" loading="lazy"></p>
<blockquote>
<p>原理</p>
</blockquote>
<p>1、我们每启动一个 docker 容器，docker 就会给 docker 容器分配一个 ip，我们只要安装了 docker，就会有一个网卡 docker0</p>
<p>2、使用桥接模式，evth-pair 技术</p>
<p>3、再启动一个容器测试，发现又多一个一对网卡</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604002613317.png" alt="image-20220604002613317" loading="lazy"></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 我们发现这个容器带来的网卡，都是一对对的</span>
<span class="token comment" spellcheck="true"># evth-pair 就是一堆的虚拟设备接口，都是成对出现的，一端连接着协议，一端彼此相连</span>
<span class="token comment" spellcheck="true"># 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的</span>
<span class="token comment" spellcheck="true"># OpenStac，Docker 容器之间的连接，OVS 的连接，都是使用 evth-pair 技术</span></code></pre>
<p>4、测试两个容器能否相互连接</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看 tomcat01 的 ip 地址</span>
docker <span class="token function">exec</span> -it tomcat01 ip addr

<span class="token comment" spellcheck="true"># 使用 tomcat02 ping tongcat01</span>
docker <span class="token function">exec</span> -it tomcat02 <span class="token function">ping</span> 172.17.0.2</code></pre>
<p>报错：OCI runtime exec failed: exec failed: unable to start container process: exec: “ping”: executable file not found in $PATH: unknown</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604004120694.png" alt="image-20220604004120694" loading="lazy"></p>
<p>解决：算了，并没有解决，反正能 ping 通的</p>
<pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it tomcat02 /bin/bash
<span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> iputils-ping</code></pre>
<p>5、原理图如下</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604004856682.png" alt="image-20220604004856682" loading="lazy"></p>
<p>结论：tomcat01 和 tomcat02 是公用一个路由器的，docker0</p>
<p>所有的容器不指定网络的情况下，都是 docker0 路由的，docker 会给我们的容器分配一个默认的可用ip</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>Docker 使用的是 Linux 的桥接，宿主机中是一个 Docker 容器的网桥，docker0</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604005054660.png" alt="image-20220604005054660" loading="lazy"></p>
<p>Docker 中的所有的网络接口都是虚拟的，虚拟的转发效率高</p>
<p>只要容器删除，对应的一对网桥就没了</p>
<blockquote>
<p>查看网络</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看网络列表</span>
docker network <span class="token function">ls</span></code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604110409054.png" alt="image-20220604110409054" loading="lazy"></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看桥接网络</span>
docker inspect 07cb58b73881</code></pre>
<p>这是 docker0 的网络配置</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604110713257.png" alt="image-20220604110713257" loading="lazy"></p>
<p>往下可以查看到 docker 的容器网络</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604110503756.png" alt="image-20220604110503756" loading="lazy"></p>
<h3 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h3><blockquote>
<p>思考</p>
</blockquote>
<p>编写了一个微服务，database url = ip；项目一重启，数据库 ip 就换掉了，我们希望可以解决这个问题，可以通过名字来进行访问容器</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 如果直接使用容器名ping不通</span>
docker <span class="token function">exec</span> -it tomcat02 <span class="token function">ping</span> tomcat01</code></pre>
<blockquote>
<p>使用 –link 命令</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 重新启动一个容器</span>
docker run -d -P --name tomcat03 --link tomcat02 tomcat</code></pre>
<p>这样启动之后，tomcat03 就可以 ping 通tomcat02</p>
<p>注意：当时 tomcat02 不能 ping 通 tomcat03</p>
<blockquote>
<p>原理</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看 tomcat03 的网络本地配置</span>
docker <span class="token function">exec</span> -it <span class="token function">cat</span> /etc/hosts</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604111521973.png" alt="image-20220604111521973" loading="lazy"></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看 tomcat02 的网络配置</span>
docker <span class="token function">exec</span> -it tomcat02 <span class="token function">cat</span> /etc/hosts</code></pre>
<p>这里并没有 tomcat03 的网络映射，所以 tomcat02 连接不通 tomcat03</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604111655312.png" alt="image-20220604111655312" loading="lazy"></p>
<p>本质：–link 就是在 hosts 配置中增加一个映射关系</p>
<p>但是现在已经不建议使用 –link 了</p>
<h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><blockquote>
<p>查看所有的 docker 网络</p>
</blockquote>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604112013286.png" alt="image-20220604112013286" loading="lazy"></p>
<p><strong>网络模式</strong></p>
<p>bridge：桥接 docker（默认）</p>
<p>none：不配置网络</p>
<p>host：和宿主机共享网络</p>
<p>container：容器网络连通（用的少，局限很大）</p>
<blockquote>
<p>测试</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 我们直接启动的命令自动使用 --net bridge，而这个就是我们的docker0</span>
docker run -d -P --name tomcat01 tomcat
docker run -d -P --name tomcat01 --net bridge tomcat

<span class="token comment" spellcheck="true"># docker0 特点：默认，不能通过容器名访问，--link 可以打通连接</span></code></pre>
<p><strong>自定义网络</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建网络</span>
<span class="token comment" spellcheck="true"># --driver 定义网络模式</span>
<span class="token comment" spellcheck="true"># --subnet 设置掩码，/16 表示前面八位二进制固定，剩下 255 * 255 - 2 个地址</span>
<span class="token comment" spellcheck="true"># --gateway 设置网关</span>
docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604113210142.png" alt="image-20220604113210142" loading="lazy"></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604113429400.png" alt="image-20220604113429400" loading="lazy"></p>
<p><strong>启动容器并配置网络</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># --net 用于设置网络</span>
docker run -d -P --name tomcat-net-01 --net mynet tomcat
docker run -d -P --name tomcat-net-02 --net mynet tomcat

<span class="token comment" spellcheck="true"># 查看自定义网络</span>
docker network inspect mynet</code></pre>
<p>此时可以看到自定义网络中新增了两个容器的网络信息</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604113731006.png" alt="image-20220604113731006" loading="lazy"></p>
<p><strong>测试连接</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以下请求都能 ping 通</span>
docker <span class="token function">exec</span> -it tomcat-net-01 <span class="token function">ping</span> 192.168.0.3
docker <span class="token function">exec</span> -it tomcat-net-01 <span class="token function">ping</span> tomcat-net-02</code></pre>
<p>我们自定义的网络 docker 都已经帮我们维护好了对应的关系</p>
<blockquote>
<p>好处</p>
</blockquote>
<p>可以用于配置不通的网络集群，例如 redis、mysql 各自的网络集群</p>
<h3 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h3><p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604124515522.png" alt="image-20220604124515522" loading="lazy"></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604124609840.png" alt="image-20220604124609840" loading="lazy"></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 测试打通</span>
docker network connect mynet tomcat01</code></pre>
<p>成功将 tomcat01 添加在 mynet 网络中，此时一个容器有两个 ip，配置之后，tomcat01 就能和 tomcat-net-01 连通了</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604124749049.png" alt="image-20220604124749049" loading="lazy"></p>
<h3 id="实战：部署-Redis-集群"><a href="#实战：部署-Redis-集群" class="headerlink" title="实战：部署 Redis 集群"></a>实战：部署 Redis 集群</h3><p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604125635082.png" alt="image-20220604125635082" loading="lazy"></p>
<p>1、创建网络</p>
<pre class=" language-bash"><code class="language-bash">docker network create redis --subnet 172.38.0.0/16</code></pre>
<p>2、编写脚本创建六个 redis 配置</p>
<pre class=" language-sh"><code class="language-sh">for port in $(seq 1 6); \
do \
mkdir -p /usr/local/docker/redis/node-${ port} /conf
touch /usr/local/docker/redis/node-${ port} /conf/redis.conf
cat << EOF >/usr/local/docker/redis/node-${ port} /conf/redis.conf
port 6379
bind 0.0.0.0
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.1${ port} 
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
done</code></pre>
<p>直接粘贴到xshell中执行即可</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604203411018.png" alt="image-20220604203411018" loading="lazy"></p>
<p>3、启动六个 redis 容器</p>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">for</span> port <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> 1 6<span class="token variable">)</span></span><span class="token punctuation">;</span> \
<span class="token keyword">do</span> \
docker run -p 637<span class="token variable">${ port}</span> :6379 -p 1637<span class="token variable">${ port}</span> :16379 --name redis-<span class="token variable">${ port}</span>  -v /usr/local/docker/redis/node-<span class="token variable">${ port}</span> /data:/data -v /usr/local/docker/redis/node-<span class="token variable">${ port}</span> /conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.38.0.1<span class="token variable">${ port}</span>  redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf 
<span class="token keyword">done</span></code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604211937224.png" alt="image-20220604211937224" loading="lazy"></p>
<p>4、创建集群</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入一个 redis 容器中</span>
docker <span class="token function">exec</span> -it redis-1 /bin/sh

<span class="token comment" spellcheck="true"># 创建集群</span>
<span class="token comment" spellcheck="true"># --replicas 1 中的1其实代表的是一个比例，就是主节点数/从节点数的比例，先是3个主节点，然后是3个从节点</span>
redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604212636066.png" alt="image-20220604212636066" loading="lazy"></p>
<p>5、连接 redis 集群</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -c 代表连接集群</span>
redis-cli -c

<span class="token comment" spellcheck="true"># 查看集群信息</span>
cluster info

<span class="token comment" spellcheck="true"># 查看节点</span>
cluster nodes</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604212904002.png" alt="image-20220604212904002" loading="lazy"></p>
<p>6、测试存值，并且关闭一台服务</p>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> name xiaojiang</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604213200537.png" alt="image-20220604213200537" loading="lazy"></p>
<p>可以发现，进行存值的时候，是主机轮流进行处理</p>
<p>7、停止 redis-2 容器进行测试</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 新建命令窗口，停止 redis-2</span>
docker stop redis-2</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604213442546.png" alt="image-20220604213442546" loading="lazy"></p>
<p>8、再次取值</p>
<pre class=" language-bash"><code class="language-bash">get name</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604213513944.png" alt="image-20220604213513944" loading="lazy"></p>
<p>此时发现是从 redis-6 从机中取到值，查看集群节点，可以看到 redis-2 发生故障，redis-6 成为主机，重启 redis-2 容器之后，发现 redis-2 成为从机</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220604213730948.png" alt="image-20220604213730948" loading="lazy"></p>
<h3 id="SpringBoot微服务打包成Docker镜像"><a href="#SpringBoot微服务打包成Docker镜像" class="headerlink" title="SpringBoot微服务打包成Docker镜像"></a>SpringBoot微服务打包成Docker镜像</h3><p>1、构建 springboot 项目，编写一个 hello，world 的 controller 就行了</p>
<p>2、打包应用</p>
<p>3、编写 dockerfile</p>
<pre class=" language-bash"><code class="language-bash">FORM java:8
COPY *.jar /app.jar
CMD <span class="token punctuation">[</span><span class="token string">"--server.port=8080"</span><span class="token punctuation">]</span>
EXPOSE 8080
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span>, <span class="token string">"-jar"</span>, <span class="token string">"/app.jar"</span><span class="token punctuation">]</span></code></pre>
<p>4、将 jar 和 dockerfile 文件上传到服务器</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220605002518856.png" alt="image-20220605002518856" loading="lazy"></p>
<p>5、构建镜像</p>
<pre class=" language-bash"><code class="language-bash">docker build -t springboot-test <span class="token keyword">.</span></code></pre>
<p>6、运行镜像</p>
<pre class=" language-bash"><code class="language-bash">docker run -d -p 9000:8080 springboot-test</code></pre>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220605002747710.png" alt="image-20220605002747710" loading="lazy"></p>
<p>以后我们使用了 Docker 之后，给别人交付的就是一个镜像了。</p>
<p>但是如果有很多个镜像需要启动，则会很麻烦，所以后续就需要使用 Docker Compose 容器编排等内容。</p>
<h2 id="13、Docker-小结"><a href="#13、Docker-小结" class="headerlink" title="13、Docker 小结"></a>13、Docker 小结</h2><blockquote>
<p>拉取镜像</p>
</blockquote>
<p>1、登录 DockerHub 官网进行搜索镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220605214030601.png" alt="image-20220605214030601" loading="lazy"></p>
<p>2、复制项目里面的拉取代码运行就可以了</p>
<p><img src="/2022/06/05/Docker%E5%AE%B9%E5%99%A8/image-20220605214116103.png" alt="image-20220605214116103" loading="lazy"></p>
<blockquote>
<p>运行镜像</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -it 交互方式运行 -d 后台运行</span>
<span class="token comment" spellcheck="true"># --name 定义容器名</span>
<span class="token comment" spellcheck="true"># -p 端口映射 -P 随机端口</span>
<span class="token comment" spellcheck="true"># -v 目录挂载</span>
docker run -it --name <span class="token punctuation">[</span>容器名<span class="token punctuation">]</span> -p 9000:8080 -v /usr/local/docker:/docker <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span></code></pre>
<blockquote>
<p>提交容器</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 提交容器成为一个新的副本</span>
<span class="token comment" spellcheck="true"># 命令和 git 原理类似</span>
docker commit -m<span class="token operator">=</span><span class="token string">"提交的描述信息"</span> -a<span class="token operator">=</span><span class="token string">"作者"</span> <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token punctuation">[</span>目标镜像名<span class="token punctuation">]</span>:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span></code></pre>
<blockquote>
<p>提交镜像</p>
</blockquote>
<p>1、提交到 DockerHub</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 登录 DockerHub</span>
docker login -u luxiaojiang123

<span class="token comment" spellcheck="true"># 生成镜像副本，将目标镜像命名为 [用户名]/[镜像名]</span>
docker tag <span class="token punctuation">[</span>原镜像<span class="token punctuation">]</span>:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span> <span class="token punctuation">[</span>目标镜像<span class="token punctuation">]</span>:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span>

<span class="token comment" spellcheck="true"># docker push [用户名]/[镜像名]</span>
docker push luxiaojiang123/diytomcat</code></pre>
<p>2、提交到 阿里云容器镜像服务</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 登录账号</span>
docker login --username<span class="token operator">=</span>晓江233 registry.cn-shenzhen.aliyuncs.com

<span class="token comment" spellcheck="true"># 生成镜像副本</span>
docker tag <span class="token punctuation">[</span>ImageId<span class="token punctuation">]</span> registry.cn-shenzhen.aliyuncs.com/luxiaojiang/diytomcat:<span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>

<span class="token comment" spellcheck="true"># 提交镜像</span>
docker push registry.cn-shenzhen.aliyuncs.com/luxiaojiang/diytomcat:<span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span></code></pre>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">谢谢光临~</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>晓江</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/" title="Docker容器">https://lxjblog.gitee.io/2022/06/05/Docker%E5%AE%B9%E5%99%A8/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/06/14/Docker%E8%BF%9B%E9%98%B6/" rel="prev" title="Docker进阶"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Docker进阶</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/10/03/Java%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" rel="next" title="Java项目部署"><span class="post-nav-text">Java项目部署</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>可以直接写评论内容喔~</span><br></div><div id="valine-container"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function initValine() {
  const valineConfig = {"enable":true,"appId":"71BKFg13iJQvNsFNLGzHmK67-gzGzoHsz","appKey":"IiQx2mfEEjefvbUfSd66nBHd","placeholder":"留下你的评论呗","avatar":"robohash","pageSize":10,"visitor":false,"highlight":true,"recordIP":false,"enableQQ":true,"el":"#valine-container","lang":"zh-cn"}
  valineConfig.path = window.location.pathname
  new Valine(valineConfig)
}
setTimeout(initValine, 1000)</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2020 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 晓江</span></div><div class="live_time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-08-04T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="总访客量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="总访问量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div><script>let date = new Date();
let today = (date.getMonth() + 1) + "-" + date.getDate()
if ("4-4,9-18".indexOf(today) !== -1) {
  document.documentElement.style.filter = "grayscale(1)";
}</script><div class="aplayer no-destroy" id="aplayer" data-id="5157675042" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="random" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="1" data-listmaxheight="340px" data-storagename="metingjs"></div></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>