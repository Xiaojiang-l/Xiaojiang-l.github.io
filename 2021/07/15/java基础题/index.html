<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="晓江"><meta name="copyright" content="晓江"><meta name="generator" content="Hexo 5.0.0"><meta name="theme" content="hexo-theme-yun"><title>java基础题 | 云端小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.16/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_stqaphw3j4.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => <!-- hexo-inject:begin --><!-- hexo-inject:end -->{
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><link rel="shortcut icon" type="image/svg+xml" href="/icon.jpg"><link rel="mask-icon" href="/icon.jpg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><link rel="alternate" href="/atom.xml" title="云端小站" type="application/atom+xml"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"云端小站","version":"0.9.4","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"}};
  </script><meta name="description" content="Java相关基础题">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础题">
<meta property="og:url" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/index.html">
<meta property="og:site_name" content="云端小站">
<meta property="og:description" content="Java相关基础题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112193743042.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112201046032.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112201955694.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221195639080.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221200952693.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221203556441.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221203815216.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210222113759020.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210222114959881.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/文档/笔记/笔记（未整理）/Java面试题.assets/image-20210221203815216.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210715225852730.png">
<meta property="article:published_time" content="2021-07-15T15:07:35.000Z">
<meta property="article:modified_time" content="2021-07-15T15:07:33.133Z">
<meta property="article:author" content="晓江">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112193743042.png"><script src="/js/ui/mode.js"></script><link rel="stylesheet" href="/css/prism.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="晓江"><img width="96" loading="lazy" src="/icon.jpg" alt="晓江"></a><div class="site-author-name"><a href="/about/">晓江</a></div><a class="site-name" href="/about/site.html">云端小站</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">42</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">15</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">46</span></a></div><a class="site-state-item hty-icon-button" href="https://lxjblog.gitee.io/myblog" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/wechat/" title="微信" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1256240778&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Xiaojiang-l" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/playlist?id=5157675042" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:1256240778@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-text">Java面试题总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-20"><span class="toc-text">1~20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="toc-text">1、Java跨平台原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Java%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">2、Java的安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Java%E4%B8%89%E5%A4%A7%E7%89%88%E6%9C%AC"><span class="toc-text">3、Java三大版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJVM%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFJDK%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFJRE%EF%BC%9F"><span class="toc-text">4、什么是JVM？什么是JDK？什么是JRE？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Java%E4%B8%89%E7%A7%8D%E6%B3%A8%E9%87%8A%E7%B1%BB%E5%9E%8B"><span class="toc-text">5、Java三种注释类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-text">6、八种基本数据类型及其字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81i-%E5%92%8C-i%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-text">7、i++和++i的异同之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81-amp-%E5%92%8C-amp-amp-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">8、 &amp;和&amp;&amp; , |和|| 的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="toc-text">9、用最有效率的方法算出2乘以8等于多少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-text">10、基本数据类型的类型转换规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81if%E5%92%8Cswitch%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-text">11、if和switch的异同之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81while%E5%92%8Cdo-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12、while和do-while循环的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81break%E5%92%8Ccontinue%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">13、break和continue的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E8%AF%B7%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97n%EF%BC%81"><span class="toc-text">14、请使用递归算法计算n！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">15、递归的定义和优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">16、数组的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81"><span class="toc-text">17、请写出冒泡排序代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">18、请写出选择排序的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">19、请写出插入排序的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-text">20、可变参数的作用和特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-40"><span class="toc-text">21~40</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">21、类和对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">22、面向过程和面向对象的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81-this%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">23、 this和super关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">24、static关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81final%E5%92%8Cabstract%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">25、final和abstract关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">26、final、finally、finalize的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E5%86%99%E5%87%BAjava-lang-Object%E7%B1%BB%E7%9A%84%E5%85%AD%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">27、写出java.lang.Object类的六个常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">28、权限修饰符的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81%E7%BB%A7%E6%89%BF%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">29、继承条件下构造方法的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">30、&#x3D;&#x3D;和equals的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E8%B0%88%E8%B0%88Java%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">31、谈谈Java的多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E7%AE%80%E8%BF%B0Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">32、简述Java的垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">33、基本数据类型和包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81Integer%E4%B8%8Eint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">34、Integer与int的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81java-sql-Date%E5%92%8Cjava-util-Date%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">35、java.sql.Date和java.util.Date的联系和区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81%E9%80%92%E5%BD%92%E5%BA%94%E7%94%A8%E9%A2%98"><span class="toc-text">36、递归应用题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81%E5%85%B3%E4%BA%8EJava%E7%BC%96%E8%AF%91%EF%BC%8C%E4%B8%8B%E9%9D%A2%E5%93%AA%E4%B8%80%E4%B8%AA%E6%AD%A3%E7%A1%AE%EF%BC%88%EF%BC%89"><span class="toc-text">37、关于Java编译，下面哪一个正确（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%9C%89%EF%BC%88%EF%BC%89"><span class="toc-text">38、下列说法正确的有（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81Java%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E4%BB%A5%E4%B8%BA%EF%BC%88%EF%BC%89"><span class="toc-text">39、Java中接口的修饰符可以为（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81%E7%BB%99%E5%AE%9A%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%B0%86%E8%BE%93%E5%87%BA-%EF%BC%88%EF%BC%89"><span class="toc-text">40、给定以下代码，程序将输出 （）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-60"><span class="toc-text">41~60</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81%E4%B8%8B%E5%88%97%E5%85%B3%E4%BA%8E%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%98%AF%EF%BC%88%EF%BC%89"><span class="toc-text">41、下列关于关键字的使用说法错误的是（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E3%80%81%E4%B8%8B%E5%88%97%E5%93%AA%E4%BA%9B%E8%AF%B4%E6%B3%95%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%88%EF%BC%89"><span class="toc-text">42、下列哪些说法是正确的（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E3%80%81%E9%80%89%E5%87%BA%E5%90%88%E7%90%86%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88%EF%BC%89"><span class="toc-text">43、选出合理的标识符（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E3%80%81%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF%EF%BC%88%EF%BC%89"><span class="toc-text">44、下列说法正确的是（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E3%80%81%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%90%8D%E4%B8%BA%E2%80%9DMyClass-java%E2%80%9D%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%AF%A5%E7%B1%BB%E5%8F%AF%E8%A2%AB%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%B1%BB%E8%AE%BF%E9%97%AE%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%A5%E7%B1%BB%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A3%B0%E6%98%8E%E4%B8%BA%EF%BC%88%EF%BC%89"><span class="toc-text">45、定义一个类名为”MyClass.java”的类，并且该类可被一个工程中的所有类访问，那么该类的正确声明为（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F%E8%AF%B7%E7%94%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90%E6%9D%A5%E6%8F%8F%E8%BF%B0%E3%80%82"><span class="toc-text">46、面向对象的特征有哪些方面？请用生活中的例子来描述。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47%E3%80%81%E8%AF%B4%E6%98%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%8C%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%8F%8F%E8%BF%B0Java%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">47、说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJava%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Java%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E5%88%97%E4%B8%BE%E5%9C%A8%E5%93%AA%E4%BA%9B%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%A7%81%E8%BF%87Java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-text">48、什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49%E3%80%81%E4%B8%8D%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%9F%E8%83%BD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="toc-text">49、不通过构造函数也能创建对象吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E6%88%96%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">50、匿名内部类可不可以继承或实现接口。为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51%E3%80%81%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E5%81%9A%E4%B8%BAHashMap%E7%9A%84%E9%94%AE%E5%80%BC%EF%BC%8C%E8%80%8C%E5%8F%AA%E8%83%BD%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8A%8A%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%81%9A%E4%B8%BAHashMap%E7%9A%84%E5%81%A5%E5%80%BC%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E3%80%82"><span class="toc-text">51、在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E3%80%81%E7%AE%80%E8%BF%B0Java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="toc-text">52、简述Java中如何实现多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E3%80%81%E4%BB%A5%E4%B8%8B%E5%AF%B9%E7%BB%A7%E6%89%BF%E7%9A%84%E6%8F%8F%E8%BF%B0%E9%94%9A%E8%AF%AF%E7%9A%84%E6%98%AF"><span class="toc-text">53、以下对继承的描述锚误的是 ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54%E3%80%81Java-%E4%B8%AD-Math-random%EF%BC%88%EF%BC%89-Math-random%EF%BC%88%EF%BC%89%E5%80%BC%E4%B8%BA%EF%BC%9F"><span class="toc-text">54、Java 中 Math.random（）&#x2F;Math.random（）值为？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55%E3%80%81Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9CManager%E6%98%AFEmployee%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%8C%E9%82%A3%E4%B9%88Pair-lt-Manager-gt-%E6%98%AFPair-lt-Employee-gt-%E7%9A%84%E5%AD%90%E7%B1%BB%E5%90%97%EF%BC%9F"><span class="toc-text">55、Java中，如果Manager是Employee的子类，那么Pair &lt;Manager&gt; 是Pair&lt;Employee&gt; 的子类吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">56、接口和抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">57、同步代码块和同步方法有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">58、静态内部类和内部类有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-text">59、反射的概念和作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60%E3%80%81%E6%8F%90%E4%BE%9BJava%E5%AD%98%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%83%BD%E5%8A%9B%E7%9A%84%E5%8C%85%E6%98%AF%EF%BC%88%EF%BC%89"><span class="toc-text">60、提供Java存取数据库能力的包是（）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-80"><span class="toc-text">61~80</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E3%80%81%E4%B8%8B%E5%88%97%E8%BF%90%E7%AE%97%E7%AC%A6%E5%90%88%E6%B3%95%E7%9A%84%E6%98%AF"><span class="toc-text">61、下列运算符合法的是()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62%E3%80%81%E6%89%A7%E8%A1%8C%E5%A6%82%E4%B8%8B%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%8Cc%E7%9A%84%E5%80%BC%E6%89%93%E5%8D%B0%E5%87%BA%E6%9D%A5%E6%98%AF"><span class="toc-text">62、执行如下程序代码，c的值打印出来是?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E3%80%81%E4%B8%8B%E5%88%97%E5%93%AA%E4%B8%80%E7%A7%8D%E5%8F%99%E8%BF%B0%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84"><span class="toc-text">63、下列哪一种叙述是正确的()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E3%80%81%E4%B8%8B%E5%88%97%E8%AF%AD%E5%8F%A5%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF"><span class="toc-text">64、下列语句正确的是()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65%E3%80%81%E4%B8%8B%E5%88%97%E5%93%AA%E7%A7%8D%E8%AF%B4%E6%B3%95%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84"><span class="toc-text">65、下列哪种说法是正确的()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89"><span class="toc-text">66、Java程序的种类有()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67%E3%80%81%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%9C%89"><span class="toc-text">67、下列说法正确的有()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68%E3%80%81%E4%B8%8B%E5%88%97%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8D%E5%90%88%E6%B3%95%E7%9A%84%E6%9C%89"><span class="toc-text">68、下列标识符不合法的有()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69%E3%80%81%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%9C%89"><span class="toc-text">69、下列说法错误的有()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70%E3%80%81%E4%B8%8D%E8%83%BD%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0interface%E7%9A%84%E6%9C%89"><span class="toc-text">70、不能用来修饰interface的有()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71%E3%80%81%E4%B8%8B%E5%88%97%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%9C%89"><span class="toc-text">71、下列正确的有()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72%E3%80%81%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%9C%89-%EF%BC%89"><span class="toc-text">72、下列说法错误的有(）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73%E3%80%81%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%9C%89"><span class="toc-text">73、下列说法错误的有()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74%E3%80%81%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%9C%89"><span class="toc-text">74、下列说法错误的有()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75%E3%80%81%E8%AF%B7%E9%97%AE0-3332%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF"><span class="toc-text">75、请问0.3332的数据类型是()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76%E3%80%81Java%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E4%BB%A5%E4%B8%BA"><span class="toc-text">76、Java接口的修饰符可以为()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77%E3%80%81%E4%B8%8D%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%9F%E8%83%BD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B9%88"><span class="toc-text">77、不通过构造函数也能创建对象么()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78%E3%80%81%E5%AD%98%E5%9C%A8%E4%BD%BF-i-1-lt-i-%E7%9A%84%E6%95%B0%E4%B9%88"><span class="toc-text">78、存在使 i+1&lt;i 的数么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79%E3%80%81%E6%8E%A5%E5%8F%A3%E5%8F%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%AE%9E%E4%BD%93%E7%B1%BB%EF%BC%9F"><span class="toc-text">79、接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80%E3%80%81int%E4%B8%8EInteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">80、int与Integer有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81-100"><span class="toc-text">81~100</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#81%E3%80%81%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89serialversionUID%E5%80%BC"><span class="toc-text">81、可序列化对象为什么要定义serialversionUID值?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82%E3%80%81%E5%86%99%E4%B8%80%E4%B8%AAJava%E6%AD%A3%E5%88%99%EF%BC%8C%E8%83%BD%E8%BF%87%E6%BB%A4%E5%87%BAhtml%E4%B8%AD%E7%9A%84title%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%E5%92%8C%E6%A0%87%E9%A2%98"><span class="toc-text">82、写一个Java正则，能过滤出html中的title中的链接地址和标题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83%E3%80%81%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B072%E8%BD%AC%E6%8D%A2%E6%88%90%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">83、十进制数72转换成八进制数是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84%E3%80%81Java%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97new%EF%BC%8C%E5%9B%9E%E6%94%B6%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97free%E6%AD%A3%E7%A1%AE%E4%B9%88%EF%BC%9F"><span class="toc-text">84、Java程序中创建新的类对象，使用关键字new，回收无用的类对象使用关键字free正确么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85%E3%80%81Class%E7%B1%BB%E7%9A%84getDeclaredFields-%E6%96%B9%E6%B3%95%E4%B8%8EgetFields-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">85、Class类的getDeclaredFields()方法与getFields()的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86%E3%80%81%E5%9C%A8switch%E5%92%8Cif-else%E8%AF%AD%E5%8F%A5%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E9%80%89%E5%8F%96%EF%BC%8C%E5%BD%93%E6%8E%A7%E5%88%B6%E9%80%89%E6%8B%A9%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%B8%8D%E4%BB%85%E4%BB%85%E4%BE%9D%E8%B5%96%E4%BA%8E%E4%B8%80%E4%B8%AAx%E6%97%B6%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8switch%E7%BB%93%E6%9E%84%EF%BC%9B%E6%AD%A3%E7%A1%AE%E4%B9%88%EF%BC%9F"><span class="toc-text">86、在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87%E3%80%81%E6%8F%8F%E8%BF%B0-amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">87、描述&amp;和&amp;&amp;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88%E3%80%81%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%9F"><span class="toc-text">88、使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89%E3%80%81%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BB%A5%E4%B8%8B%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E5%90%AB%E4%B9%89%EF%BC%9A-d-D-s-0-9-6-d"><span class="toc-text">89、请解释以下常用正则含义：\d,\D,\s,.,*,?,|,[0-9]{6},\d+</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90%E3%80%81%E5%B7%B2%E7%9F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8Fint-m-0-1-2-3-4-5-6-%E4%B8%8B%E9%9D%A2%E9%82%A3%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E7%9B%B8%E7%AD%89"><span class="toc-text">90、已知表达式int m[] &#x3D; {0,1,2,3,4,5,6}; 下面那个表达式的值与数组的长度相等()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91%E3%80%81%E4%B8%8B%E9%9D%A2%E9%82%A3%E4%BA%9B%E5%A3%B0%E6%98%8E%E6%98%AF%E5%90%88%E6%B3%95%E7%9A%84%EF%BC%9F"><span class="toc-text">91、下面那些声明是合法的？()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92%E3%80%81%E4%BB%A5%E4%B8%8B%E9%80%89%E9%A1%B9%E4%B8%AD%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84java%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">92、以下选项中选择正确的java表达式()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93%E3%80%81%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF"><span class="toc-text">93、下列代码的输出结果是()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94%E3%80%81%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E5%90%AB%E6%9C%89%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%E6%9C%BA%E5%88%B6%E7%9A%84%EF%BC%9F"><span class="toc-text">94、以下哪些运算符是含有短路运算机制的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#95%E3%80%81%E4%B8%8B%E9%9D%A2%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AFpublic-void-example-%E2%80%A6-%E7%9A%84%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%9F%EF%BC%88%EF%BC%89"><span class="toc-text">95、下面哪个函数是public void example(){….}的重载函数？（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96%E3%80%81%E7%BB%99%E5%AE%9A%E6%9F%90java%E7%A8%8B%E5%BA%8F%E7%89%87%E6%AE%B5%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%90%8E%EF%BC%8Cj%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%BA%EF%BC%88%EF%BC%89"><span class="toc-text">96、给定某java程序片段，该程序运行后，j的输出结果为（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#97%E3%80%81%E5%9C%A8java%E4%B8%AD%EF%BC%8C%E6%97%A0%E8%AE%BA%E6%B5%8B%E8%AF%95%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%8B%E5%88%97%EF%BC%88%EF%BC%89%E5%BE%AA%E7%8E%AF%E5%B0%86%E8%87%B3%E5%B0%91%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E3%80%82"><span class="toc-text">97、在java中，无论测试条件是什么，下列（）循环将至少执行一次。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98%E3%80%81%E6%B1%82%E5%87%BD%E6%95%B0%E8%BE%93%E5%85%A5%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-text">98、求函数输入结果？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99%E3%80%81%E6%8C%87%E5%87%BA%E4%B8%8B%E5%88%97%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-text">99、指出下列程序的运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100%E3%80%81%E8%A7%A3%E9%87%8A%E7%BB%A7%E6%89%BF%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96"><span class="toc-text">100、解释继承、重载、覆盖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-120"><span class="toc-text">101~120</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="晓江"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="云端小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">java基础题</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-07-15 23:07:35" itemprop="dateCreated datePublished" datetime="2021-07-15T23:07:35+08:00">2021-07-15</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/java%E5%9F%BA%E7%A1%80/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">java基础</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/java/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://img-blog.csdnimg.cn/20210628000220859.jpg"></div><span class="author-name">晓江</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="Java面试题总结"><a href="#Java面试题总结" class="headerlink" title="Java面试题总结"></a>Java面试题总结</h2><h2 id="1-20"><a href="#1-20" class="headerlink" title="1~20"></a>1~20</h2><h3 id="1、Java跨平台原理"><a href="#1、Java跨平台原理" class="headerlink" title="1、Java跨平台原理"></a>1、Java跨平台原理</h3><blockquote>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>字节码文件、虚拟机</p>
</blockquote>
<ul>
<li>C/C++语言都直接编译成针对特定平台机器码，如果要跨平台，需要使用相应的编译重新编译。</li>
<li>Java源程序（.java）要先编译成与平台无关的字节码文件（.class），然后字节码文件在解释成机器码运行，Java虚拟机来执行。</li>
<li>字节码文件不面向任何具体平台，只面向虚拟机。</li>
<li>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</li>
<li>Java语言具有一次编译，到处运行的特点，就是说编译后的.class文件可以跨平台运行，前提是该平台具有相应的Java虚拟机，但是性能比C/C++要低。</li>
<li>Java的跨平台原理决定其性能没有C/C++高。</li>
</ul>
<p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112193743042.png" alt="image-20210112193743042" loading="lazy"></p>
<h3 id="2、Java的安全性"><a href="#2、Java的安全性" class="headerlink" title="2、Java的安全性"></a>2、Java的安全性</h3><blockquote>
<p>语言层次</p>
</blockquote>
<p><strong>Java取消了强大但又危险的指针</strong>，而代之为引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</p>
<blockquote>
<p>垃圾回收机制</p>
</blockquote>
<p><strong>不需要程序员直接控制内存回收</strong>，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄漏。避免程序错误回收程序核心类库的内存，导致系统崩溃。</p>
<blockquote>
<p>异常处理机制</p>
</blockquote>
<p>Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</p>
<blockquote>
<p>强制类型转换</p>
</blockquote>
<p>只有在满足强制转换规则的情况下才能强转成功。</p>
<blockquote>
<p>底层的安全性</p>
</blockquote>
<ul>
<li><p>Java在字节码的传输过程中使用了公开密钥加密机制（PKC）</p>
</li>
<li><p>在运行环境提供了四级安全性保障机制：</p>
<p>字节码校验器 - 类装载器 - 运行时内存布局 - 文件访问权限</p>
</li>
</ul>
<h3 id="3、Java三大版本"><a href="#3、Java三大版本" class="headerlink" title="3、Java三大版本"></a>3、Java三大版本</h3><p><strong>Java平台包括标准版（J2SE）、企业版（J2EE）和微压缩版（J2ME）三个版本：</strong></p>
<ul>
<li><p><strong>Standard Edition(标准版)</strong> J2SE 包含那些构成Java语言核心的类。</p>
<p>比如：数据库连接、接口定义、输入/输出、网络编程</p>
</li>
<li><p><strong>Enterprise Edition(企业版)</strong> J2EE 包含J2SE 中的类，并且还包含用于开发企业级应用的类。</p>
<p>比如servlet、JSP、XML、事务控制</p>
</li>
<li><p><strong>Micro Edition(微缩版)</strong> J2ME 包含J2SE中一部分类，用于消费类电子产品的软件开发。</p>
<p>比如：呼机、智能卡、手机、PDA、机顶盒</p>
</li>
</ul>
<p><strong>他们的范围是：</strong><br>J2SE包含于J2EE中，J2ME包含了J2SE的核心类，但新添加了一些专有类应用场合，API的覆盖范围各不相同。</p>
<h3 id="4、什么是JVM？什么是JDK？什么是JRE？"><a href="#4、什么是JVM？什么是JDK？什么是JRE？" class="headerlink" title="4、什么是JVM？什么是JDK？什么是JRE？"></a>4、什么是JVM？什么是JDK？什么是JRE？</h3><blockquote>
<p>JVM</p>
</blockquote>
<p><strong>JVM是Java Virtual Machine（Java虚拟机）的缩写</strong>，它是整个Java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。<strong>JVM是Java平台的基础</strong>，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 <strong>JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。</strong>JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。</p>
<blockquote>
<p>JRE</p>
</blockquote>
<p><strong>JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行</strong>，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib，<strong>在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和lib和起来就称为jre</strong>。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。<strong>JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的</strong>（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。</p>
<blockquote>
<p>JDK</p>
</blockquote>
<p><strong>JDK是java development kit（java开发工具包）的缩写。</strong>每个学java的人都会先在机器上装一个JDK，那让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。</p>
<ul>
<li><strong>bin:</strong> 最主要的是编译器(javac.exe)</li>
<li><strong>include:</strong> java和JVM交互用的头文件</li>
<li><strong>lib：</strong>类库</li>
<li><strong>jre:</strong> java运行环境</li>
</ul>
<p>（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）<br>总的来说<strong>JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能</strong>。eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。</p>
<blockquote>
<p>JDK、JRE、JVM三者关系概括如下：</p>
</blockquote>
<ul>
<li>JDK是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。</li>
<li>JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。</li>
<li>JDK、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li>
</ul>
<h3 id="5、Java三种注释类型"><a href="#5、Java三种注释类型" class="headerlink" title="5、Java三种注释类型"></a>5、Java三种注释类型</h3><p>共有单行注释、多行注释、文档注释3种注释类型。</p>
<ul>
<li><p><strong>单行注释，采用<code>//</code>方式.只能注释一行代码。如：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 类成员变量</span></code></pre>
</li>
<li><p><strong>多行注释，采用<code>/*...*/</code>方式，可注释多行代码，其中不允许出现嵌套。如：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
System.out.println("a");
System.out.println("b");
System.out.println("c");
*/</span></code></pre>
</li>
<li><p>文档注释，采用<code>/**...*/</code>方式，如：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
* @author 晓江
* @descripted QQ:1256240778 
*/</span></code></pre>
</li>
</ul>
<h3 id="6、八种基本数据类型及其字节数"><a href="#6、八种基本数据类型及其字节数" class="headerlink" title="6、八种基本数据类型及其字节数"></a>6、八种基本数据类型及其字节数</h3><p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112201046032.png" alt="image-20210112201046032" loading="lazy"></p>
<h3 id="7、i-和-i的异同之处"><a href="#7、i-和-i的异同之处" class="headerlink" title="7、i++和++i的异同之处"></a>7、i++和++i的异同之处</h3><p><strong>共同点：</strong></p>
<ol>
<li><p>i++和++i都是变量自增1，都等价于i=i+1</p>
</li>
<li><p>如果i++,++i是一条单独的语句，两者没有任何区别</p>
</li>
<li><p>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</p>
</li>
</ol>
<p><strong>不同点：</strong></p>
<ul>
<li>如果i++,++i不是一条单独的语句，他们就有区别<br>i++ ：先运算后增1。</li>
<li>++i ： 先增1后运算</li>
</ul>
<h3 id="8、-amp-和-amp-amp-和-的区别和联系"><a href="#8、-amp-和-amp-amp-和-的区别和联系" class="headerlink" title="8、 &amp;和&amp;&amp; , |和|| 的区别和联系"></a>8、 &amp;和&amp;&amp; , |和|| 的区别和联系</h3><p><strong>&amp;和&amp;&amp;的联系(共同点)：</strong></p>
<ul>
<li><p>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定</p>
</li>
<li><p>操作数1 &amp; 操作数2，操作数1 &amp;&amp; 操作数2</p>
</li>
<li><p>表达式1 &amp; 表达式2，表达式1 &amp;&amp; 表达式2</p>
<p><strong>情况1</strong>：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p>
<p><strong>情况2</strong>：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</p>
</li>
</ul>
<p><strong>&amp;和&amp;&amp;的区别(不同点)：</strong></p>
<ol>
<li><p><strong>&amp; 称为逻辑与运算符，&amp;&amp; 称为短路与运算符，也可叫逻辑与运算符。</strong></p>
<p><strong>对于&amp;：</strong>无论任何情况，&amp;两边的操作数或表达式都会参与计算。</p>
<p><strong>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时</strong>，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</p>
<p>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。<strong>推荐平时多使用&amp;&amp;，因为它效率更高些。</strong></p>
</li>
<li><p><strong>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</strong></p>
</li>
</ol>
<p>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</p>
<h3 id="9、用最有效率的方法算出2乘以8等于多少"><a href="#9、用最有效率的方法算出2乘以8等于多少" class="headerlink" title="9、用最有效率的方法算出2乘以8等于多少"></a>9、用最有效率的方法算出2乘以8等于多少</h3><ul>
<li>使用位运算来实现效率最高。<strong>位运算符是对操作数以二进制比特位为单位进行操作和运算</strong>，操作数和结果都是整型数。</li>
<li><strong>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方</strong>，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高。所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3</li>
</ul>
<h3 id="10、基本数据类型的类型转换规则"><a href="#10、基本数据类型的类型转换规则" class="headerlink" title="10、基本数据类型的类型转换规则"></a>10、基本数据类型的类型转换规则</h3><blockquote>
<p>基本类型转换分为自动转换和强制转换。</p>
</blockquote>
<ul>
<li><p><strong>自动转换规则：</strong><br><strong>容量小的数据类型可以自动转换成容量大的数据类型</strong>，也可以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的范围。</p>
<p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112201955694.png" alt="image-20210112201955694" loading="lazy"></p>
</li>
<li><p><strong>强制转换规则：</strong></p>
<p>高级变为低级需要强制转换：</p>
<ol>
<li>赋值运算符“=”右边的转换，<strong>先自动转换成表达式中级别最高的数据类型</strong>，再进行运算。</li>
<li>赋值运算符“=”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 == 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</li>
<li><strong>可以将整型常量直接赋值给byte, short, char等类型变量</strong>，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</li>
</ol>
</li>
</ul>
<h3 id="11、if和switch的异同之处"><a href="#11、if和switch的异同之处" class="headerlink" title="11、if和switch的异同之处"></a>11、if和switch的异同之处</h3><ul>
<li><p><strong>相同之处：</strong></p>
<p>都是分支语句，对超过一种的情况进行判断处理。</p>
</li>
<li><p><strong>不同之处：</strong><br>switch更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有break跳出），不加判断地执行下去; 而if—else if—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。<strong>switch为等值判断（不允许比如&gt;= &lt;=），而if为等值和区间都可以，if的使用范围大。</strong></p>
</li>
</ul>
<h3 id="12、while和do-while循环的区别"><a href="#12、while和do-while循环的区别" class="headerlink" title="12、while和do-while循环的区别"></a>12、while和do-while循环的区别</h3><ul>
<li>while先判断后执行，第一次判断为false , 循环体一次都不执行。 do while先执行后判断，最少执行1次。</li>
<li>如果while循环第一次判断为true, 则两种循环没有区别。</li>
</ul>
<h3 id="13、break和continue的作用"><a href="#13、break和continue的作用" class="headerlink" title="13、break和continue的作用"></a>13、break和continue的作用</h3><ul>
<li>break: 结束当前循环并退出当前循环体。break还可以退出switch语句</li>
<li>continue: 当前循环中后续的语句不执行，但是循环体没有结束，继续进行循环条件的判断（for循环还会i++）。 continue只是结束本次循环。</li>
</ul>
<h3 id="14、请使用递归算法计算n！"><a href="#14、请使用递归算法计算n！" class="headerlink" title="14、请使用递归算法计算n！"></a>14、请使用递归算法计算n！</h3><blockquote>
<p>Recursion 读法:[rɪˈkɜ:rʃn] 递归</p>
</blockquote>
<p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。 自然数n的阶乘写作n!。 1808年，基斯顿·卡曼引进这个表示法。 亦即n!=1×2×3×…×n。阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Recursion</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">//阶乘算法</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span> 
            <span class="token keyword">return</span> num<span class="token operator">*</span><span class="token function">factorial</span><span class="token punctuation">(</span>num<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        Recursion recursion <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Recursion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> factorial <span class="token operator">=</span> recursion<span class="token punctuation">.</span><span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>factorial<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="15、递归的定义和优缺点"><a href="#15、递归的定义和优缺点" class="headerlink" title="15、递归的定义和优缺点"></a>15、递归的定义和优缺点</h3><blockquote>
<p><strong>递归算法是一种直接或者间接地调用自身算法的过程。</strong>在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</p>
</blockquote>
<p><strong>递归算法解决问题的特点：</strong></p>
<ol>
<li>递归就是在过程或函数里调用自身。</li>
<li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
<li>递归算法解题通常显得很简洁，但<strong>运行效率较低，所以一般不提倡用递归算法设计程序。</strong></li>
<li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。<strong>递归次数过多容易造成栈溢出等</strong>。所以一般不提倡用递归算法设计程序。</li>
</ol>
<h3 id="16、数组的特征"><a href="#16、数组的特征" class="headerlink" title="16、数组的特征"></a>16、数组的特征</h3><blockquote>
<p>数组是（相同类型数据）的（有序）（集合）</p>
</blockquote>
<p>数组会在内存中开辟一块连续的空间，每个空间相当于之前的一个变量，称为数组的元素element</p>
<p>元素的表示：数组名[下标或者索引] <code>scores[7] scores[0] scores[9]</code>，索引从0开始</p>
<p>每个数组元素有默认值 <code>double 0.0; boolean false; int 0</code></p>
<p>数组元素有序的，不是大小顺序，是索引的顺序</p>
<p>数组中可以存储基本数据类型，可以存储引用数据类型；但是对于一个数组而言，数组的类型是固定的，只能是一个length:数组的长度</p>
<p>数组的长度是固定的，一经定义，不能再发生变化（数组的扩容）</p>
<h3 id="17、请写出冒泡排序代码"><a href="#17、请写出冒泡排序代码" class="headerlink" title="17、请写出冒泡排序代码"></a>17、请写出冒泡排序代码</h3><blockquote>
<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。</p>
</blockquote>
<p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。</p>
<p>走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
<p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<p><strong>冒泡排序算法的原理如下：</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221195639080.png" alt="image-20210221195639080" loading="lazy"></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bubble</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 外层循环，它决定一共走几趟 //-1为了防止溢出</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//通过符号位可以减少无谓的比较，如果已经有序了，就退出循环</span>
            <span class="token comment" spellcheck="true">//内层循环，它决定每趟走一次</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                <span class="token comment" spellcheck="true">//如果后一个大于前一个,则换位</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                    temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                    flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> 
            <span class="token punctuation">}</span> 
            <span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span> 
        <span class="token keyword">return</span> array<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        Bubble bubble <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bubble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sort <span class="token operator">=</span> bubble<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span>sort<span class="token punctuation">)</span><span class="token punctuation">{</span> 
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="18、请写出选择排序的代码"><a href="#18、请写出选择排序的代码" class="headerlink" title="18、请写出选择排序的代码"></a>18、请写出选择排序的代码</h3><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法。</p>
<p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221200952693.png" alt="image-20210221200952693" loading="lazy"></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectSort</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token comment" spellcheck="true">// 认为目前的数就是最小的, 记录最小数的下标</span>
            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                    <span class="token comment" spellcheck="true">// 修改最小值的下标</span>
                    minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> 
            <span class="token punctuation">}</span> 
            <span class="token comment" spellcheck="true">// 当退出for就找到这次的最小值,就需要交换位置了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> minIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                <span class="token comment" spellcheck="true">//交换当前值和找到的最小值的位置</span>
                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span> 
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        SelectSort selectSort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SelectSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sort <span class="token operator">=</span> selectSort<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span>sort<span class="token punctuation">)</span><span class="token punctuation">{</span> 
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="19、请写出插入排序的代码"><a href="#19、请写出插入排序的代码" class="headerlink" title="19、请写出插入排序的代码"></a>19、请写出插入排序的代码</h3><blockquote>
<p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法。</p>
</blockquote>
<p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。</p>
<p>插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
<p><strong>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</strong>包括：<strong>直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）</strong>。属于稳定排序的一种（通俗地讲，就是两个相等的数不会交换位置）。</p>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li><p>从第一个元素开始，该元素可以认为已经被排序 </p>
</li>
<li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描 </p>
</li>
<li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置 </p>
</li>
<li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 </p>
</li>
<li><p>将新元素插入到下一位置中 </p>
</li>
<li><p>重复步骤2~5</p>
</li>
</ol>
<p><strong>如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。</strong>该算法可以认为是插入排序的一个变种，称为二分查找排序。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token punctuation">{</span> 
    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token comment" spellcheck="true">//如果传入的数组为空或者只有一个值,就直接返回</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token comment" spellcheck="true">//不为空则进循环判断</span>
        <span class="token comment" spellcheck="true">//外层循环控制总数量</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token comment" spellcheck="true">//内层循环依次减少并提出结果</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
                <span class="token comment" spellcheck="true">//如果当前数字小于前一个,则交换,否则不变</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
                    <span class="token keyword">int</span> temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span> 
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> 
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span> 
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        InsertSort insertSort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InsertSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sort <span class="token operator">=</span> insertSort<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span>sort<span class="token punctuation">)</span><span class="token punctuation">{</span> 
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="20、可变参数的作用和特点"><a href="#20、可变参数的作用和特点" class="headerlink" title="20、可变参数的作用和特点"></a>20、可变参数的作用和特点</h3><p>详解 : <a target="_blank" rel="noopener" href="https://www.cnblogs.com/uptownBoy/articles/1698335.html">https://www.cnblogs.com/uptownBoy/articles/1698335.html</a></p>
<blockquote>
<p>总结1：</p>
</blockquote>
<ol>
<li><p>可变参数的形式 …</p>
</li>
<li><p>可变参数只能是方法的形参</p>
</li>
<li><p>可变参数对应的实参可以0,1,2…..n个，也可以是一个数组</p>
</li>
<li><p>在可变参数的方法中，将可变参数当做数组来处理</p>
</li>
<li><p>可变参数最多有一个，只能是最后一个</p>
</li>
<li><p>可变参数好处：方便 简单 减少重载方法的数量</p>
</li>
<li><p>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</p>
</li>
</ol>
<blockquote>
<p>总结2： 数组做形参和可变参数做形参联系和区别</p>
</blockquote>
<p><strong>联系：</strong></p>
<ol>
<li>实参都可以是数组；</li>
<li>方法体中，可变参数本质就是当做数组来处理</li>
</ol>
<p><strong>区别：</strong></p>
<ol>
<li><p>个数不同 可变参数只能有一个数组参数可以多个</p>
</li>
<li><p>位置不同 可变参数只能是最后一个 数组参数位置任意</p>
</li>
<li><p>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</p>
</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 指定类型的参数</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        sum <span class="token operator">+=</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span> </code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通用类型参数</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintfSample</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token function">printOut</span><span class="token punctuation">(</span><span class="token string">"Pi:%f E:%f\n"</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>PI<span class="token punctuation">,</span> Math<span class="token punctuation">.</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printOut</span><span class="token punctuation">(</span>String format<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h2 id="21-40"><a href="#21-40" class="headerlink" title="21~40"></a>21~40</h2><h3 id="21、类和对象的关系"><a href="#21、类和对象的关系" class="headerlink" title="21、类和对象的关系"></a>21、类和对象的关系</h3><p><strong>类是对象的抽象，而对象是类的具体实例。</strong> 类是抽象的，不占用内存，而对象是具体的，占用存储空间。 类是用于创建对象的蓝图，类就是一个带方法和变量的特定类型。</p>
<p>类和对象好比图纸和实物的关系，模具和铸件的关系。</p>
<p>比如人类就是一个概念，人类具有身高，体重等属性。人类可以做吃饭、说话等方法。</p>
<p>小明就是一个具体的人，也就是实例，他的属性是具体的身高200cm，体重180kg，他做的方法是具体的吃了一碗白米饭，说了“12345”这样一句话。</p>
<p>还可以有小红,小蓝等具体的人即对象,但他们都是人类的实例,即类.</p>
<h3 id="22、面向过程和面向对象的区别"><a href="#22、面向过程和面向对象的区别" class="headerlink" title="22、面向过程和面向对象的区别"></a>22、面向过程和面向对象的区别</h3><p>两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。</p>
<p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221203556441.png" alt="image-20210221203556441" loading="lazy"></p>
<p><strong>比喻:</strong></p>
<p>面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。蛋炒饭就不行了, 如果不满意就要丢掉重做;</p>
<blockquote>
<p>区别:</p>
</blockquote>
<p><strong>编程思路不同：</strong> 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</p>
<p><strong>封装性：</strong>都具有封装性，<strong>但是面向过程封装的是功能，而面向对象封装的是数据和功能</strong>。面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</p>
<p><strong>方法重载和方法重写（覆盖）的区别:</strong></p>
<p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221203815216.png" alt="image-20210221203815216" loading="lazy"></p>
<h3 id="23、-this和super关键字的作用"><a href="#23、-this和super关键字的作用" class="headerlink" title="23、 this和super关键字的作用"></a>23、 this和super关键字的作用</h3><p>this是对象内部指代自身的引用，同时也是解决成员变量和局部变量同名问题；this可以调用成员变量，不能调用局部变量；this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句。而且<strong>在静态方法当中不允许出现this关键字</strong>,<em>（static叫静态方法，也叫类方法，它先于任何的对象出现。在程序最开始启动（JVM初始化）的时候，就会为static方法分配一块内存空间，称为静态区，属于这个类。而非static方法，必须在类实例化的时候，才会给分配内存空间，在实例化对象的时候JVM在堆区分配一个具体的对象，this指针指向这个对象。也就是说，this指针是指向堆区中的类的对象，而static域不属于this指向的范围所在，所以不能调用。）。</em></p>
<p>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如<strong>不能访问private成员</strong>）</p>
<p>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且<strong>必须是第一条语句。</strong></p>
<h3 id="24、static关键字的作用"><a href="#24、static关键字的作用" class="headerlink" title="24、static关键字的作用"></a>24、static关键字的作用</h3><p><strong>static可以修饰变量、方法、代码块和内部类。</strong></p>
<p>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过<code>对象名.属性名</code>和<code>类名.属性名</code>两种方式来访问。也可以在没有创建任何对象之前通过<code>类名.属性名</code>的方式来访问。</p>
<p>.static变量和非static变量的区别(都是成员变量，不是局部变量)</p>
<p><strong>1、在内存中份数不同</strong></p>
<p>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份。<strong>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量。</strong></p>
<p><strong>2、在内存中存放的位置不同</strong></p>
<p>静态变量存在方法区中， 实例变量存在堆内存中。</p>
<p>static静态变量先于任何的对象出现。在程序最开始启动（JVM初始化）的时候，就会为static方法分配一块内存空间，称为静态区，属于这个类。</p>
<p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210222113759020.png" alt="image-20210222113759020" loading="lazy"></p>
<p><strong>3、访问的方式不同</strong></p>
<ul>
<li><strong>实例变量</strong>： 对象名.变量名 stu1.name=”小明明”;</li>
<li><strong>静态变量</strong>：<ul>
<li><strong>对象名.变量名</strong> stu1.schoolName=”西二旗小学”; 不推荐如此使用</li>
<li><strong>类名.变量名</strong> Student.schoolName=”东三旗小学”; 推荐使用</li>
</ul>
</li>
</ul>
<p><strong>4、在内存中分配空间的时间不同</strong></p>
<ul>
<li>实例变量：创建对象的时候才分配了空间</li>
<li>静态变量：第一次使用类的时候</li>
</ul>
<p>Student.schoolName=”东三旗小学”;或者Student stu1 = new Student(“小明”,”男”,20,98);</p>
<p>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</p>
<p>static代码块，当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</p>
<p><strong>static内部类</strong>：属于整个外部类，而不是属于外部类的每个对象。<strong>不能访问外部类的非静态成员（变量或者方法），可以访问外部类的静态成员。</strong></p>
<h3 id="25、final和abstract关键字的作用"><a href="#25、final和abstract关键字的作用" class="headerlink" title="25、final和abstract关键字的作用"></a>25、final和abstract关键字的作用</h3><blockquote>
<p>final和abstract是功能相反的两个关键字，可以对比记忆</p>
</blockquote>
<p><strong>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；</strong>使用abstract修饰的类是<strong>抽象类，需要被继承</strong>，使用abstract修饰的方法是<strong>抽象方法，需要被子类重写。</strong></p>
<ul>
<li>修饰类、方法</li>
<li>抽象类需要被继承</li>
</ul>
<p><strong>final可以用来修饰类、方法和属性，不能修饰构造方法。</strong>使用<strong>final修饰的类不能被继承，使用final修饰的方法不能被重写</strong>，使用final修饰的变量的值不能被修改，所以就成了常量。</p>
<ul>
<li>修饰类、方法 和 属性</li>
<li>类不能被继承</li>
<li>方法不能被重写</li>
<li>基本类型变量不能被修改（常量）</li>
<li>引用类型变量指向的堆内存不能改，但对象属性可以修改（即可以修改对象的某些变量值）</li>
</ul>
<p>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；<strong>但是final修饰引用类型变量</strong>，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">final</span> People people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"大黄"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//正确</span>
        people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">"大黄"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//错误</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="26、final、finally、finalize的区别"><a href="#26、final、finally、finalize的区别" class="headerlink" title="26、final、finally、finalize的区别"></a>26、final、finally、finalize的区别</h3><blockquote>
<p>final</p>
</blockquote>
<p><strong>final修饰符(关键字)如果一个类被声明为final</strong>，意味着它不能再派生出新的子类，不能作为父类被继承例如：String类、Math类等。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为<strong>final的方法也同样只能使用，不能重写，但是能够重载</strong>。使用final修饰的对象，对象的引用地址不能变，但是对象的值可以变!</p>
<blockquote>
<p>finally</p>
</blockquote>
<p><strong>finally在异常处理时提供 finally 块来执行任何清除操作</strong>。如果有finally的话，则不管是否发生异常，<strong>finally语句都会被执行。</strong>一般情况下，都把关闭物理连接(IO流、数据库连接、Socket连接)等相关操作，放入到此代码块中。</p>
<blockquote>
<p>finalize</p>
</blockquote>
<p><strong>finalize方法名</strong>。Java 技术允许使用 finalize() 方法<strong>在垃圾收集器将对象从内存中清除出去之前做必要清理工作。</strong></p>
<p><strong>finalize() 方法是在垃圾收集器删除对象之前被调用的</strong>。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。 一般情况下，<strong>此方法由JVM调用</strong>，程序员不要去调用!</p>
<h3 id="27、写出java-lang-Object类的六个常用方法"><a href="#27、写出java-lang-Object类的六个常用方法" class="headerlink" title="27、写出java.lang.Object类的六个常用方法"></a>27、写出java.lang.Object类的六个常用方法</h3><blockquote>
<p>equals() 比较对象的地址值</p>
</blockquote>
<p>(1)public boolean <strong>equals</strong>(java.lang.Object)<strong>比较对象的地址值是否相等</strong>，如果子类重写，则比较对象的内容是否相等；</p>
<blockquote>
<p>hashcode() 判断是否同一个对象</p>
</blockquote>
<p>(2)public native int <strong>hashCode</strong>() 获取哈希码</p>
<blockquote>
<p>toString() 转为字符串</p>
</blockquote>
<p>(3)public java.lang.String <strong>toString</strong>() 把数据转变成字符串</p>
<blockquote>
<p>getClass() 获取类的结构信息</p>
</blockquote>
<p>(4)public final native java.lang.Class <strong>getClass</strong>() 获取类结构信息</p>
<blockquote>
<p>finalize() 垃圾回收前自动执行的方法</p>
</blockquote>
<p>(5)protected void <strong>finalize</strong>() throws java.lang.Throwable垃圾回收前执行的方法</p>
<blockquote>
<p>clone() 克隆对象（原型模式）</p>
</blockquote>
<p>(6)protected native Object <strong>clone</strong>() throws java.lang.CloneNotSupportedException 克隆</p>
<blockquote>
<p>wait() 在多线程中进行等待</p>
</blockquote>
<p>(7)public final void <strong>wait</strong>() throws java.lang.InterruptedException多线程中等待功能</p>
<blockquote>
<p>notify() 唤醒一个等待的线程</p>
</blockquote>
<p>(8)public final native void <strong>notify</strong>() 多线程中唤醒功能</p>
<blockquote>
<p>notifyAll() 唤醒所有等待线程</p>
</blockquote>
<p>(9)public final native void <strong>notifyAll</strong>() 多线程中唤醒所有等待线程的功能</p>
<h3 id="28、权限修饰符的区别"><a href="#28、权限修饰符的区别" class="headerlink" title="28、权限修饰符的区别"></a>28、权限修饰符的区别</h3><p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210222114959881.png" alt="image-20210222114959881" loading="lazy"></p>
<p><strong>类的访问权限只有两种:</strong></p>
<ul>
<li><strong>public</strong> 公共的 可被同一项目中所有的类访问。 (必须与文件名同名，所以一个文件只能有一个 public 的类)</li>
<li><strong>default</strong> 默认的 可被同一个包中的类访问。</li>
</ul>
<p><strong>成员(成员变量或成员方法)访问权限共有四种：</strong></p>
<ul>
<li><strong>public</strong> 公共的 可以被项目中所有的类访问。(项目可见性)</li>
<li><strong>protected</strong> 受保护的 可以被这个<strong>类本身</strong>访问；<strong>同一个包中</strong>的所有其他的类访问；被它的<strong>子类</strong>(同一个包以及不同包中的子类)访问。(子类可见性)</li>
<li><strong>default</strong> 默认的被这个<strong>类本身</strong>访问；被<strong>同一个包</strong>中的类访问。(包可见性)</li>
<li><strong>private</strong> 私有的 只能被这个<strong>类本身</strong>访问。(类可见性)</li>
</ul>
<h3 id="29、继承条件下构造方法的执行过程"><a href="#29、继承条件下构造方法的执行过程" class="headerlink" title="29、继承条件下构造方法的执行过程"></a>29、继承条件下构造方法的执行过程</h3><p><strong>继承条件下构造方法的调用规则如下：</strong></p>
<ul>
<li><strong>情况1</strong>：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。（<strong>构造方法没有super和this时，默认优先调用父类的无参构造方法</strong>）</li>
<li><strong>情况2</strong>：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</li>
<li><strong>情况3</strong>：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</li>
</ul>
<h3 id="30、-和equals的区别和联系"><a href="#30、-和equals的区别和联系" class="headerlink" title="30、==和equals的区别和联系"></a>30、==和equals的区别和联系</h3><p><strong>“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</strong></p>
<blockquote>
<p>“==”，比较有父子关系的对象</p>
</blockquote>
<ol>
<li>基本类型，比较的是值</li>
<li>引用类型，比较的是地址</li>
<li><strong>不能比较没有父子关系的两个对象</strong></li>
</ol>
<blockquote>
<p>equals()，默认比较地址</p>
</blockquote>
<ol>
<li><strong>系统类一般已经覆盖了equals()，比较的是内容。</strong></li>
<li>用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址（return (this == obj);）</li>
<li>用户自定义类需要覆盖父类的equals()</li>
</ol>
<p><strong>注意：Object的==和equals比较的都是地址，作用相同</strong></p>
<blockquote>
<p>八种基本数据类型</p>
</blockquote>
<p>1、整数型</p>
<ul>
<li><strong>int：</strong>计算机默认整数类型都为int，占4个字节，范围为正负21亿多，如果定义一个int类型变量超出范围会报错。</li>
<li><strong>double</strong>：计算机默认小数类型都为double，占8个字节，当参与运算时，二进制识别不了1/10，所以会发生舍入误差，导致不精确。</li>
<li><strong>byte、short、float、long</strong>分别占1、2、4、8个字节，除非声明该变量类型，否则所有整数类型运算默认为int类型计算。 </li>
</ul>
<p>2、字符型</p>
<ul>
<li><strong>char</strong>:定义该变量时需要用单引号‘’引用，或者用数字，有且只有一个字符，占2个字节，在计算机中是16位无符号整数形式存储，unicode全球统一编码范围为0-65535，65–A，97–a,48–0,特殊符号需要用\转义</li>
</ul>
<p>3、布尔类型</p>
<ul>
<li><strong>boolean</strong>:占一个字节，赋值只能为true或false,用于条件判断。</li>
</ul>
<h3 id="31、谈谈Java的多态"><a href="#31、谈谈Java的多态" class="headerlink" title="31、谈谈Java的多态"></a>31、谈谈Java的多态</h3><blockquote>
<p>概念（动态、灵活、扩展性）</p>
</blockquote>
<p>多态性是OOP中的一个重要特性，<strong>主要是用来实现动态联编的</strong>，换句话说，<strong>就是程序的最终状态只有在执行过程中才被决定</strong>而非在编译期间就决定了。<strong>这对于大型系统来说能提高系统的灵活性和扩展性</strong>。</p>
<p>多态可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，从而实现更加灵活的编程，提高系统的可扩展性。</p>
<blockquote>
<p>条件（继承）</p>
</blockquote>
<p><strong>实现多态的三个条件（前提条件，向上转型、向下转型）</strong></p>
<ol>
<li>继承的存在（<strong>继承是多态的基础，没有继承就没有多态</strong>）</li>
<li>子类重写父类的方法（多态下会调用子类重写后的方法）</li>
<li>父类引用变量指向子类对象（涉及子类到父类的类型转换）</li>
</ol>
<blockquote>
<p>类型转换</p>
</blockquote>
<p><strong>向上转型 Animal a = new Cat();</strong></p>
<ul>
<li><strong>将一个父类的引用指向一个子类对象，称为向上转型</strong>，自动进行类型转换。此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法,此时通过父类引用变量无法调用子类特有的方法。</li>
</ul>
<p><strong>向下转型 Cat a2 = (Cat)a;</strong></p>
<ul>
<li>将一个指向子类对象的引用赋给一个子类的引用，称为向下转型，此时必须进行强制类型转换。<strong>向下转型必须转换为父类引用指向的真实子类类型</strong>，否则将出现ClassCastException，不是任意的强制转换。</li>
<li>向下转型时可以结合使用instanceof运算符进行强制类型转换，比如出现转换异常–ClassCastException.比如：本来是狗，我把它转成猫。就会报这个异常。</li>
</ul>
<h3 id="32、简述Java的垃圾回收机制"><a href="#32、简述Java的垃圾回收机制" class="headerlink" title="32、简述Java的垃圾回收机制"></a>32、简述Java的垃圾回收机制</h3><p>传统的C/C++语言，需要程序员负责回收已经分配内存。</p>
<blockquote>
<p>显式回收垃圾（非Java）</p>
</blockquote>
<p><strong>显式回收垃圾回收的缺点：</strong></p>
<ol>
<li>程序忘记及时回收，从而导致内存泄露，降低系统性能。</li>
<li>程序错误回收程序核心类库的内存，导致系统崩溃。</li>
</ol>
<p><strong>Java语言不需要程序员直接控制内存回收，是由JRE在后台自动回收不再使用的内存，称为垃圾回收机制，简称GC；</strong></p>
<ol>
<li>可以提高编程效率。</li>
<li>保护程序的完整性。</li>
<li>其开销影响性能。Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。</li>
</ol>
<blockquote>
<p>垃圾回收机制</p>
</blockquote>
<p><strong>垃圾回收机制的特点:</strong></p>
<ol>
<li>垃圾回收机制回收JVM堆内存里的对象空间，<strong>不负责回收栈内存数据</strong>。</li>
<li>对其他物理连接，比如数据库连接、输入流输出流、Socket<strong>连接无能为力</strong>。</li>
<li>垃圾回收发生具有<strong>不可预知性</strong>，程序无法精确控制垃圾回收机制执行。</li>
<li>可以<strong>将对象的引用变量设置为null</strong>，暗示垃圾回收机制可以回收该对象。</li>
</ol>
<p><strong>现在的JVM有多种垃圾回收实现算法，表现各异。</strong></p>
<ul>
<li><p>垃圾回收机制回收任何对象之前，<strong>总会先调用它的finalize方法</strong>（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。</p>
</li>
<li><p>程序员可以<strong>通过<code>System.gc()</code>或者<code>Runtime.getRuntime().gc()</code>来通知系统进行垃圾回收</strong>，会有一些效果，但是系统是否进行垃圾回收依然不确定。</p>
</li>
<li><p>永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</p>
</li>
</ul>
<h3 id="33、基本数据类型和包装类"><a href="#33、基本数据类型和包装类" class="headerlink" title="33、基本数据类型和包装类"></a>33、基本数据类型和包装类</h3><p><strong>1、八个基本数据类型的包装类</strong></p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p><strong>2、为什么为基本类型引入包装类</strong></p>
<ul>
<li>基本数据类型有方便之处，简单、高效。</li>
<li>但是<strong>Java中的基本数据类型却是不面向对象的（没有属性、方法）</strong>，这在实际使用时存在很多的不便（比如集合的元素只能是Object）</li>
</ul>
<p>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p>
<p><strong>3、包装类和基本数据类型之间的转换</strong></p>
<ul>
<li>包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型</li>
<li>包装类&lt;—new WrapperClass(primitive)– new WrapperClass(string)——基本数据类型</li>
</ul>
<p><strong>4、自动装箱和自动拆箱</strong></p>
<p>​    JDK1.5提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换。</p>
<p><strong>5、包装类还可以实现基本类型变量和字符串之间的转换</strong></p>
<ul>
<li>基本类型变量————String.valueof()————&gt;字符串</li>
<li>基本类型变量&lt;————WrapperClass.parseXxx(string)————字符串</li>
</ul>
<h3 id="34、Integer与int的区别"><a href="#34、Integer与int的区别" class="headerlink" title="34、Integer与int的区别"></a>34、Integer与int的区别</h3><p><strong>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</strong></p>
<blockquote>
<p>默认值</p>
</blockquote>
<p><strong>int的默认值为0，而Integer的默认值为null</strong>，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</p>
<p><strong>在Hibernate中，如果将OID定义为Integer类型</strong>，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p>
<p>另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<h3 id="35、java-sql-Date和java-util-Date的联系和区别"><a href="#35、java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="35、java.sql.Date和java.util.Date的联系和区别"></a>35、java.sql.Date和java.util.Date的联系和区别</h3><p>​    1）、java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQLDATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，<strong>java.sql.Date就是与数据库Date相对应的一个类型</strong>，而java.util.Date是纯java的Date。</p>
<p>​    2）、JAVA里提供的日期和时间类java.sql.Date和java.sql.Timestamp,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包2002/05/22 5:00:57 PM的字段，读取日期时得到的是2002/05/22，而读取时间时得到的是5:00:57 PM，你需要了解数据库里存储时间的精度。有些数据库，比如MySQL，精度为毫秒，然而另一些数据库，包括Oracle，存储SQL DATE类型数据时，毫秒部分的数据是不保存的。</p>
<p>以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 , 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象 , 用Equals方法可能返回false。<code>java.sql.Timestamp</code>类比<code>java.util.Date</code>类精确度要高。</p>
<p><code>java.sql.Date </code>和<code>java.util.Date</code> 最大的不同在于<code>java.sql.Date </code>只记录日期，而没有具体这一天的时间。所以举例来说，如果当前是2009-12-24 23:20，你创建一个java.sql.Date 将只记下2009-12-24这个信息。若你需要保留时间进行JDBC操作，请使用<code>java.sql.Timestamp </code>代替。</p>
<p>总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分。</p>
<p><strong>总结：</strong></p>
<ol>
<li>java.util.Date 可以记录完整的时间，包括 日期 和 时间</li>
<li>java.sql.Date 针对SQL语句使用的，只记录日期。需要通过java.sql.Timestamp 来记录 时间</li>
</ol>
<h3 id="36、递归应用题"><a href="#36、递归应用题" class="headerlink" title="36、递归应用题"></a>36、递归应用题</h3><p>题目 : 使用递归算法输出某个目录下及其子目录下所有文件.</p>
<p>递归 : 自动调用自己 , 需要定义递归出口.</p>
<p>题目分析 : 参数为一个指定的目录 . 输出所有文件列表;</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShowFile</span> <span class="token punctuation">{</span> 
<span class="token comment" spellcheck="true">/*
静态私有化方法的特点：
1. 方法只能在类内部使用。
2. 性能提高，静态的函数无需检测this指针是否为空。
（一般函数的第一个参数是对象本身，而静态的可以为null,不需要额外的检查)
*/</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>String path<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment" spellcheck="true">//list()方法是返回某个目录下的所有文件和目录的文件名，返回的是String数组</span>
        <span class="token comment" spellcheck="true">//listFiles()方法是返回某个目录下所有文件和目录的绝对路径，返回的是File数组</span>
        File f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        File<span class="token punctuation">[</span><span class="token punctuation">]</span> fs <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果没有文件,返回空;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token comment" spellcheck="true">//递归遍历输出</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>File file <span class="token operator">:</span> fs<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token comment" spellcheck="true">//如果是文件就直接打印出来,否则就递归循环</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span> 
                <span class="token function">test</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        String path <span class="token operator">=</span> <span class="token string">"E:\\生活\\图片"</span><span class="token punctuation">;</span>
        <span class="token function">test</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="37、关于Java编译，下面哪一个正确（）"><a href="#37、关于Java编译，下面哪一个正确（）" class="headerlink" title="37、关于Java编译，下面哪一个正确（）"></a>37、关于Java编译，下面哪一个正确（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>Java程序经编译后产生machine code (机器代码)</td>
</tr>
<tr>
<td>B</td>
<td>Java程序经编译后会生产byte code (字节码)</td>
</tr>
<tr>
<td>C</td>
<td>Java程序经编译后会产生DLL (动态链接库)</td>
</tr>
<tr>
<td>D</td>
<td>以上都不正确</td>
</tr>
</tbody></table>
<p>答案：B</p>
<p>分析： Java是解释型语言，编译出来的是字节码； 因此A不正确，C是C/C++语言编译动态链接库的文件为.DLL； 正确答案为B</p>
<h3 id="38、下列说法正确的有（）"><a href="#38、下列说法正确的有（）" class="headerlink" title="38、下列说法正确的有（）"></a>38、下列说法正确的有（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>class中的construtor不可省略</td>
</tr>
<tr>
<td>B</td>
<td>construtor与class同名，但方法不能与class同名</td>
</tr>
<tr>
<td>C</td>
<td>construtor在一个对象被new时执行</td>
</tr>
<tr>
<td>D</td>
<td>一个class只能定义一个construtor</td>
</tr>
</tbody></table>
<p>答案：C</p>
<p>分析：A：如果class中的construtor省略不写，系统会默认提供一个无参构造</p>
<p>B：方法名可以与类名同名，只是不符合命名规范</p>
<p>D：一个class中可以定义N多个construtor，这些construtor构成构造方法的重载</p>
<h3 id="39、Java中接口的修饰符可以为（）"><a href="#39、Java中接口的修饰符可以为（）" class="headerlink" title="39、Java中接口的修饰符可以为（）"></a>39、Java中接口的修饰符可以为（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>private</td>
</tr>
<tr>
<td>B</td>
<td>protected</td>
</tr>
<tr>
<td>C</td>
<td>final</td>
</tr>
<tr>
<td>D</td>
<td>abstract</td>
</tr>
</tbody></table>
<p>答案：D</p>
<p>分析：</p>
<p>A、B：接口中的<strong>访问权限修饰符只可以是public或default</strong></p>
<p>C：接口中的所有的方法必须要实现类实现，所以不能使用final</p>
<p>D：接口中所有的<strong>方法默认都是abstract的</strong>，所以接口可以使用abstract修饰，但通常abstract可以省略不写</p>
<h3 id="40、给定以下代码，程序将输出-（）"><a href="#40、给定以下代码，程序将输出-（）" class="headerlink" title="40、给定以下代码，程序将输出 （）"></a>40、给定以下代码，程序将输出 （）</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        B b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>不能通过编译</td>
</tr>
<tr>
<td>B</td>
<td>通过编译，输出AB</td>
</tr>
<tr>
<td>C</td>
<td>通过编译，输出B</td>
</tr>
<tr>
<td>D</td>
<td>通过编译，输出A</td>
</tr>
</tbody></table>
<p>答案：B</p>
<p>分析：在继承关系下，创建子类对象，没有使用super和this，先执行父类的构造方法，再执行子类的构造方法。</p>
<h2 id="41-60"><a href="#41-60" class="headerlink" title="41~60"></a>41~60</h2><h3 id="41、下列关于关键字的使用说法错误的是（）"><a href="#41、下列关于关键字的使用说法错误的是（）" class="headerlink" title="41、下列关于关键字的使用说法错误的是（）"></a>41、下列关于关键字的使用说法错误的是（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>abstract不能与final并列修饰同一个类</td>
</tr>
<tr>
<td>B</td>
<td>abstract类中可以有private的成员</td>
</tr>
<tr>
<td>C</td>
<td>abstract方法必须在abstract类中</td>
</tr>
<tr>
<td>D</td>
<td>static方法能处理非static的属性</td>
</tr>
</tbody></table>
<p>答案：D </p>
<p>分析：<strong>因为static的方法在装载class的时候首先完成，比构造方法早</strong>，此时非static的属性和方法还没有完成初始化所以不能调用。</p>
<h3 id="42、下列哪些说法是正确的（）"><a href="#42、下列哪些说法是正确的（）" class="headerlink" title="42、下列哪些说法是正确的（）"></a>42、下列哪些说法是正确的（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>程序员必须创建一个线程来释放内存</td>
</tr>
<tr>
<td>B</td>
<td>内存回收程序负责释放无用内存</td>
</tr>
<tr>
<td>C</td>
<td>内存回收程序允许程序员直接释放内存</td>
</tr>
<tr>
<td>D</td>
<td>内存回收程序可以在指定的时间释放内存对象</td>
</tr>
</tbody></table>
<p>答案：B</p>
<p>分析： A. 程序员不需要创建线程来释放内存. C. 也不允许程序员直接释放内存. D. 不一定在什么时刻执行垃圾回收。</p>
<h3 id="43、选出合理的标识符（）"><a href="#43、选出合理的标识符（）" class="headerlink" title="43、选出合理的标识符（）"></a>43、选出合理的标识符（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>_sysl_111</td>
</tr>
<tr>
<td>B</td>
<td>2mail</td>
</tr>
<tr>
<td>C</td>
<td>$change</td>
</tr>
<tr>
<td>D</td>
<td>class</td>
</tr>
</tbody></table>
<p>答案：AC</p>
<p>分析： 标识符的命令规范，可以包含字母、数字、下划线、$，不能以数字开头，不能是Java关键字</p>
<h3 id="44、下列说法正确的是（）"><a href="#44、下列说法正确的是（）" class="headerlink" title="44、下列说法正确的是（）"></a>44、下列说法正确的是（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>java.lang.Cloneable是类</td>
</tr>
<tr>
<td>B</td>
<td>java.lang.Runnable是接口</td>
</tr>
<tr>
<td>C</td>
<td>Double对象在java.lang包中</td>
</tr>
<tr>
<td>D</td>
<td>Double a=1.0是正确的java语句</td>
</tr>
</tbody></table>
<p>答案：BCD</p>
<p>分析：java.lang.Cloneable是接口</p>
<h3 id="45、定义一个类名为”MyClass-java”的类，并且该类可被一个工程中的所有类访问，那么该类的正确声明为（）"><a href="#45、定义一个类名为”MyClass-java”的类，并且该类可被一个工程中的所有类访问，那么该类的正确声明为（）" class="headerlink" title="45、定义一个类名为”MyClass.java”的类，并且该类可被一个工程中的所有类访问，那么该类的正确声明为（）"></a>45、定义一个类名为”MyClass.java”的类，并且该类可被一个工程中的所有类访问，那么该类的正确声明为（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>private class MyClass extends Object</td>
</tr>
<tr>
<td>B</td>
<td>class MyClass extends Object</td>
</tr>
<tr>
<td>C</td>
<td>public class MyClass</td>
</tr>
<tr>
<td>D</td>
<td>public class MyClass extends Object</td>
</tr>
</tbody></table>
<p>答案：CD</p>
<p>分析： A：<strong>类的访问权限只能是public或default</strong></p>
<p>​            B：使用默认访问权限的类，只能在本包中访问（default）</p>
<h3 id="46、面向对象的特征有哪些方面？请用生活中的例子来描述。"><a href="#46、面向对象的特征有哪些方面？请用生活中的例子来描述。" class="headerlink" title="46、面向对象的特征有哪些方面？请用生活中的例子来描述。"></a>46、面向对象的特征有哪些方面？请用生活中的例子来描述。</h3><blockquote>
<p>三大特征：</p>
</blockquote>
<p>封装、继承、多态</p>
<blockquote>
<p>比如设计一个游戏</p>
</blockquote>
<ol>
<li><p>我建了一个对象，叫人</p>
<ul>
<li>属性 : 性别，年龄，职业，等级，血量 </li>
<li>方法 : 逃跑，吃饭，睡觉，死</li>
</ul>
</li>
<li><p>我现在创建了一个对象，名叫战士</p>
<ul>
<li><p>属性 : 性别，年龄，职业，等级，战斗力，血量</p>
</li>
<li><p>方法 : 战斗，逃跑，吃饭，睡觉，死。</p>
</li>
</ul>
</li>
</ol>
<p>此时还没有使用继承，可以看出战士和人具有相同的属性和方法</p>
<blockquote>
<p>让 “人” 成为 “父类”</p>
</blockquote>
<ol>
<li><p>我让人，成为战士的父类，战士可以直接继承人的属性和方法</p>
</li>
<li><p>战士的属性和方法只需设置如下：</p>
<ul>
<li>属性 : 战斗力</li>
<li>方法 : 战斗</li>
</ul>
<p>看上去战士的资料变少了，实际上没有，我们仍然可以调用方法—战士.死。 而且我们还可以重载<code>战士.死</code>的方法，简称重载死法。</p>
</li>
<li><p>我还建了一个对象—法师，父类也是人：</p>
<ul>
<li>属性 : 法力值</li>
<li>方法 : 施法</li>
</ul>
</li>
</ol>
<p>用了继承，创建对象变得更方便了</p>
<blockquote>
<p>创建父类 “怪物”</p>
</blockquote>
<ol>
<li>建立了一个对象，叫怪物：<ul>
<li>属性 : 等级，战力，血量</li>
<li>方法 : 战斗，死。</li>
</ul>
</li>
<li>建了个对象，叫白兔怪，父类怪物，可继承怪物所有的属性和方法<ul>
<li>属性 : 毛色</li>
<li>方法 : 卖萌，吃胡萝卜</li>
</ul>
</li>
</ol>
<h3 id="47、说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？"><a href="#47、说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？" class="headerlink" title="47、说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？"></a>47、说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？</h3><blockquote>
<p>内存泄漏memory leak </p>
</blockquote>
<ul>
<li>是指程序在申请内存后，<strong>无法释放已申请的内存空间</strong>，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</li>
</ul>
<blockquote>
<p>内存溢出 out of memory </p>
</blockquote>
<ul>
<li>指程序申请内存时，<strong>没有足够的内存供申请者使用</strong>，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM，即所谓的内存溢出。</li>
</ul>
<blockquote>
<p>泄露和溢出的关系</p>
</blockquote>
<p><strong>关系：</strong></p>
<ul>
<li>内存泄漏的堆积最终会导致内存溢出，<strong>内存溢出就是你要的内存空间超过了系统实际分配给你的空间</strong>，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</li>
<li>内存泄漏是指你向系统申请分配内存进行使用(new)，可是**使用完了以后却不归还(delete)**，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。</li>
</ul>
<p><strong>举例：</strong></p>
<ul>
<li>内存泄漏：就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</li>
<li>内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错。</li>
</ul>
<blockquote>
<p>内存泄漏的分类（按发生方式来分类）</p>
</blockquote>
<ul>
<li><p><strong>常发性内存泄漏</strong>：发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 </p>
</li>
<li><p><strong>偶发性内存泄漏</strong>：发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。</p>
<p>常发性和偶发性是相对的，对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 </p>
</li>
<li><p><strong>一次性内存泄漏</strong>：发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。</p>
</li>
<li><p><strong>隐式内存泄漏</strong>：程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。</p>
</li>
</ul>
<blockquote>
<p>内存溢出的原因及解决方法</p>
</blockquote>
<ol>
<li><p><strong>内存溢出原因：</strong></p>
<p><strong>内存中加载的数据量过于庞大</strong>，如一次从数据库取出过多数据； 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 代码中存在死循环或循环产生过多重复的对象实体； 使用的第三方软件中的BUG； 启动参数内存值设定的过小。</p>
</li>
<li><p><strong>内存溢出的解决方案：</strong></p>
<p>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p>
<p>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。</p>
<p>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</p>
<p><strong>重点排查以下几点：</strong></p>
<ol>
<li><p>检查对数据库查询中，<strong>是否有一次获得全部数据的查询</strong>。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</p>
</li>
<li><p>检查代码中是否有死循环或递归调用。</p>
</li>
<li><p>检查是否有大循环重复产生新对象实体。</p>
</li>
<li><p>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</p>
</li>
<li><p>检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。第四步，使用内存查看工具动态查看内存使用情况</p>
</li>
</ol>
</li>
</ol>
<h3 id="48、什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"><a href="#48、什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？" class="headerlink" title="48、什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"></a>48、什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？</h3><blockquote>
<p>序列化概念</p>
</blockquote>
<p>只是序列化了对象的属性，不包括方法。</p>
<ul>
<li>将实例对象的状态信息写入到字节流中</li>
<li>在需要的时候通过字节流中的信息重构对象</li>
</ul>
<p>Java中的序列化机制能够将一个实例对象（只序列化对象的属性值，而不会去序列化什么所谓的方法。）的<strong>状态信息写入到一个字节流中使其可以通过socket进行传输、或者持久化到存储数据库或文件系统中</strong>；然后在需要的时候<strong>通过字节流中的信息来重构一个相同的对象</strong>。</p>
<p>一般而言，要使得一个类可以序列化，只需简单实现<code>java.io.Serializable</code>接口即可。</p>
<blockquote>
<p>作用</p>
</blockquote>
<ol>
<li>把对象的<strong>字节序列</strong>永久地保存到硬盘上，通常存放在一个文件中；</li>
<li>在网络上传送对象的字节序列</li>
</ol>
<p>在很多应用中，<strong>需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存</strong>。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p>
<p>当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。<strong>发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</strong></p>
<h3 id="49、不通过构造函数也能创建对象吗？"><a href="#49、不通过构造函数也能创建对象吗？" class="headerlink" title="49、不通过构造函数也能创建对象吗？"></a>49、不通过构造函数也能创建对象吗？</h3><p><strong>Java创建对象的几种方式（重要）：</strong></p>
<p>1、 <strong>用new语句创建对象</strong>，这是最常见的创建对象的方法。</p>
<pre class=" language-java"><code class="language-java">People people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>2、 <strong>运用反射手段</strong>，调用java.lang.Class或者java.lang.reflect.Constructor类的<code>newInstance()</code>实例方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 反射获取构造器</span>
Constructor<span class="token operator">&lt;</span>LazyMan<span class="token operator">></span> declaredConstructor <span class="token operator">=</span> LazyMan<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 无视私有构造器</span>
declaredConstructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 通过反射创建对象</span>
LazyMan instance2 <span class="token operator">=</span> declaredConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>3、 <strong>调用对象的clone()方法</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建一个原型</span>
Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Proto proto <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proto</span><span class="token punctuation">(</span><span class="token string">"原型1"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 克隆</span>
Proto clone <span class="token operator">=</span> <span class="token punctuation">(</span>Proto<span class="token punctuation">)</span> proto<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>4、运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li>1 和 2 都会明确的显式的调用构造函数 ；</li>
<li>3 是在内存上对已有对象的影印，所以不会调用构造函数 ；</li>
<li>4 是从文件中还原类的对象，也不会调用构造函数。</li>
</ul>
<h3 id="50、匿名内部类可不可以继承或实现接口。为什么？"><a href="#50、匿名内部类可不可以继承或实现接口。为什么？" class="headerlink" title="50、匿名内部类可不可以继承或实现接口。为什么？"></a>50、匿名内部类可不可以继承或实现接口。为什么？</h3><blockquote>
<p>匿名类不可以继承</p>
</blockquote>
<ul>
<li>匿名内部类是没有名字的内部类，不能继承其它类。</li>
<li><strong>但一个内部类可以作为一个接口，由另一个内部类实现</strong>。</li>
</ul>
<blockquote>
<p>原因</p>
</blockquote>
<p>1、由于<strong>匿名内部类没有名字，所以它没有构造函数</strong>。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把创建对象的任务交给了父类去完成。</p>
<p>2、在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是<strong>多态性的体现</strong>。</p>
<p>3、因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或z间接父类类型。</p>
<blockquote>
<p>匿名类概念</p>
</blockquote>
<p><strong>匿名类是不能有名称的类</strong>，所以没办法引用它们。必须在创建时，作为new语句的一部分来声明它们。</p>
<p>这就要采用另一种形式的new语句，如下所示： <code>new &lt;类或接口&gt; &lt;类的主体&gt;</code></p>
<p>这种形式的new语句声明一个新的匿名类，它对一个给定的类进行扩展，或者实现一个给定的接口。它还创建那个类的一个新实例，并把它作为语句的结果而返回。要扩展的类和要实现的接口是new语句的操作数，后跟匿名类的主体。</p>
<p>如果匿名类对另一个类进行扩展，它的主体可以访问类的成员、覆盖它的方法等等，这和其他任何标准的类都是一样的。如果匿名类实现了一个接口，它的主体必须实现接口的方法。</p>
<p><strong>注意匿名类的声明是在编译时进行的，实例化在运行时进行。这意味着for循环中的一个new语句会创建相同匿名类的几个实例，而不是创建几个不同匿名类的一个实例。</strong></p>
<p>从技术上说，匿名类可被视为非静态的内部类，所以它们具有和方法内部声明的非静态内部类一样的权限和限制。</p>
<p>如果要执行的任务需要一个对象，但却不值得创建全新的对象（原因可能是所需的类过于简单，或者是由于它只在一个方法内部使用），匿名类就显得非常有用。匿名类尤其适合在Swing应用程序中快速创建事件处理程序。</p>
<p>具体可参考博文 : <a target="_blank" rel="noopener" href="https://blog.csdn.net/liupeng900605/article/details/7723529">https://blog.csdn.net/liupeng900605/article/details/7723529</a></p>
<h3 id="51、在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><a href="#51、在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。" class="headerlink" title="51、在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"></a>51、在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</h3><blockquote>
<p>原因</p>
</blockquote>
<ol>
<li>在Java中是<strong>使用泛型来约束</strong>HashMap中的key和value的类型的，即HashMap&lt;K, V&gt;</li>
<li>而<strong>泛型在Java的规定中必须是对象Object类型的</strong>，也就是说HashMap&lt;K, V&gt;可以理解为HashMap&lt;Object,Object&gt;</li>
<li>很显然<strong>基本数据类型不是Object类型</strong>的，因此不能作为键值，只能是引用类型</li>
</ol>
<p>虽然我们在HashMap中可以这样添加数据：“map.put(1,“Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型。</p>
<blockquote>
<p>引用数据类型</p>
</blockquote>
<p>引用数据类型分为两类：</p>
<ol>
<li><strong>引用数据类型</strong></li>
<li><strong>自定义引用数据类型</strong>（需要自己<strong>重写HashCode()和equals()这两个方法</strong>）</li>
</ol>
<p>系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。</p>
<h3 id="52、简述Java中如何实现多态"><a href="#52、简述Java中如何实现多态" class="headerlink" title="52、简述Java中如何实现多态"></a>52、简述Java中如何实现多态</h3><blockquote>
<p>三个前提条件</p>
</blockquote>
<ol>
<li>继承的存在（继承是多态的基础，没有继承就没有多态）。</li>
<li>子类重写父类的方法（多态下会调用子类重写后的方法）。</li>
<li>父类引用变量指向子类对象（涉及子类到父类的类型转换）。</li>
</ol>
<p>最后<strong>使用父类的引用变量调用子类重写的方法即可实现多态</strong>。即,同一个方法 , 可以有不同的展现结果。</p>
<h3 id="53、以下对继承的描述锚误的是"><a href="#53、以下对继承的描述锚误的是" class="headerlink" title="53、以下对继承的描述锚误的是 ()"></a>53、以下对继承的描述锚误的是 ()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>Java中的继承允许一个子类继承多个父类</td>
</tr>
<tr>
<td>B</td>
<td>父类更具有通用性，子类更具体</td>
</tr>
<tr>
<td>C</td>
<td>Java中的继承存在着传递性</td>
</tr>
<tr>
<td>D</td>
<td>当实例化子类时会递归调用父类中的构造方法</td>
</tr>
</tbody></table>
<p>答案：A<br>分析：Java是单继承的，一个类只能继承一个父类。</p>
<h3 id="54、Java-中-Math-random（）-Math-random（）值为？"><a href="#54、Java-中-Math-random（）-Math-random（）值为？" class="headerlink" title="54、Java 中 Math.random（）/Math.random（）值为？"></a>54、Java 中 Math.random（）/Math.random（）值为？</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<p>调用这个Math.Random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是[0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该范围内（近似）均匀分布</p>
<ul>
<li>如果除数与被除数均不为0.0的话，则取值范围为[0, +∞]。+∞在Java中显示的结果为Infinity</li>
<li>如果被除数为0.0的话，则运行结果为NaN（Not a Number的简写），计算错误</li>
</ul>
<h3 id="55、Java中，如果Manager是Employee的子类，那么Pair-lt-Manager-gt-是Pair-lt-Employee-gt-的子类吗？"><a href="#55、Java中，如果Manager是Employee的子类，那么Pair-lt-Manager-gt-是Pair-lt-Employee-gt-的子类吗？" class="headerlink" title="55、Java中，如果Manager是Employee的子类，那么Pair &lt;Manager&gt; 是Pair&lt;Employee&gt; 的子类吗？"></a>55、Java中，如果Manager是Employee的子类，那么<code>Pair &lt;Manager&gt; </code>是<code>Pair&lt;Employee&gt; </code>的子类吗？</h3><ul>
<li>不是，两者没有任何关联；</li>
<li>Pair是单独的类，只不过用不同类型的参数（泛型）进行了相应的实例化而已；所以，<code>Pair&lt;Manager&gt; </code>和<br><code>Pair&lt;Employee&gt; </code>不是子类的关系。</li>
</ul>
<h3 id="56、接口和抽象类的区别"><a href="#56、接口和抽象类的区别" class="headerlink" title="56、接口和抽象类的区别"></a>56、接口和抽象类的区别</h3><blockquote>
<p>相同点</p>
</blockquote>
<ol>
<li>抽象类和接口均包含抽象方法，类必须实现所有的抽象方法</li>
<li>抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继承和实现</li>
</ol>
<blockquote>
<p>区别</p>
</blockquote>
<p>两者的区别主要体现在两方面：<strong>语法方面</strong>和<strong>设计理念</strong>方面</p>
<ul>
<li><p>语法方面的区别：是比较 低层次的，非本质的，主要表现在：</p>
<ul>
<li><strong>接口中只能定义全局静态常量，不能定义变量</strong>。抽象类中可以定义常量和变量。</li>
<li>接口中所有的方法都是全局抽象方法。抽象类中可以有0个、1个或多个，甚至全部都是抽象方法。</li>
<li><strong>抽象类中可以有构造方法，但不能用来实例化，而在子类实例化执行</strong>，完成属于抽象类的初始化操作。<strong>接口中不能定义构造方法。</strong></li>
<li><strong>一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口</strong>。一个类使用extends来继承抽象类，使用implements来实现接口。</li>
</ul>
</li>
<li><p>设计理念上的区别：其决定了某些情况下到底使用抽象类还是接口。</p>
<ul>
<li><strong>抽象类体现了一种继承关系，目的是复用代码</strong>，抽象类中定义了各个子类的相同代码，可以认为父类是一个实现了部分功能的“中间产品”，而子类是“最终产品”。</li>
<li><strong>接口并不要求实现类和接口在概念本质上一致的，仅仅是实现了接口定义的约定或者能力而已</strong>。接口定义了“做什么”，而实现类负责完成“怎么做”，体现了功能（规范）和实现分离的原则。</li>
</ul>
</li>
</ul>
<h3 id="57、同步代码块和同步方法有什么区别"><a href="#57、同步代码块和同步方法有什么区别" class="headerlink" title="57、同步代码块和同步方法有什么区别"></a>57、同步代码块和同步方法有什么区别</h3><blockquote>
<p>相同点</p>
</blockquote>
<ul>
<li><strong>同步方法</strong>：就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。</li>
<li><strong>同步代码块</strong>：则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个<strong>同步的“目标”</strong>，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。</li>
</ul>
<p>一般情况下，如果此“目标”为this，那么同步方法和同步代码块没有太大的区别。</p>
<blockquote>
<p>区别</p>
</blockquote>
<ul>
<li>同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。</li>
<li>一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。</li>
</ul>
<h3 id="58、静态内部类和内部类有什么区别"><a href="#58、静态内部类和内部类有什么区别" class="headerlink" title="58、静态内部类和内部类有什么区别"></a>58、静态内部类和内部类有什么区别</h3><p>定义方式不同：</p>
<ol>
<li>静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。</li>
<li>静态内部类可以有静态成员(方法，属性)，而<strong>非静态内部类则不能有静态成员</strong>(方法，属性)。</li>
<li>非静态内部类能够访问外部类的静态和非静态成员。<strong>静态内部类不能访问外部类的非静态成员</strong>，只能访问外部类的静态成员。</li>
</ol>
<p>实例化方式不同：</p>
<ol>
<li>静态内部类：不依赖于外部类的实例，直接实例化内部类对象 [ 是真的类 ]</li>
<li>非静态内部类：通过外部类的对象实例生成内部类对象 [ 是在对象中new出来的类 ]</li>
</ol>
<h3 id="59、反射的概念和作用"><a href="#59、反射的概念和作用" class="headerlink" title="59、反射的概念和作用"></a>59、反射的概念和作用</h3><blockquote>
<p>概念</p>
</blockquote>
<p><strong>反射，一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。</strong></p>
<ul>
<li>Java反射可以于运行时加载，探知和使用编译期间完全未知的类，程序在运行状态中，<strong>可以动态加载一个只有名称的类</strong></li>
<li>对于任意一个已经加载的类，都能够知道这个类的<strong>所有属性和方法</strong></li>
<li>对于任意一个对象，都能调用他的任意一个方法和属性</li>
<li>加载完类之后，在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了完整的类的结构信息，而且这个Class对象就像一面镜子，透过这个镜子看到类的结构，所以被称之为<strong>反射</strong></li>
<li>java反射使得我们可以<strong>在程序运行时动态加载一个类</strong>，动态获取类的基本信息和定义的方法，构造函数，域等。</li>
<li>除了检阅类信息外，还可以动态创建类的实例，执行类实例的方法，获取类实例的域值。反射使java这种静态<br>语言有了动态的特性。</li>
</ul>
<blockquote>
<p>反射的作用</p>
</blockquote>
<p>通过反射可以使程序代码访问装载到 JVM 中的类的内部信息</p>
<ol>
<li>获取已装载类的属性信息</li>
<li>获取已装载类的方法</li>
<li>获取已装载类的构造方法信息</li>
</ol>
<blockquote>
<p>反射的优点</p>
</blockquote>
<p><strong>增加程序的灵活性</strong>。 如struts中，请求的派发控制，当请求来到时。struts通过查询配置文件，找到该请求对应的<br>action，然后通过反射实例化action，并调用响应method。 如果不适用反射，那么你就只能写死到代码里了。 所以说，一个灵活，一个不灵活。 很少情况下是非用反射不可的，大多数情况下反射是为了提高程序的灵活性。 因此一般框架中使用较多，因为框架要适用更多的情况，对灵活性要求较高。</p>
<h3 id="60、提供Java存取数据库能力的包是（）"><a href="#60、提供Java存取数据库能力的包是（）" class="headerlink" title="60、提供Java存取数据库能力的包是（）"></a>60、提供Java存取数据库能力的包是（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>java.sql</td>
</tr>
<tr>
<td>B</td>
<td>java.awt</td>
</tr>
<tr>
<td>C</td>
<td>java.lang</td>
</tr>
<tr>
<td>D</td>
<td>java.swing</td>
</tr>
</tbody></table>
<p>答案：A</p>
<p>分析：java.awt和javax.swing两个包是图形用户界面编程所需要的包；java.lang包则提供了Java编程中用到的基础类。</p>
<h2 id="61-80"><a href="#61-80" class="headerlink" title="61~80"></a>61~80</h2><h3 id="61、下列运算符合法的是"><a href="#61、下列运算符合法的是" class="headerlink" title="61、下列运算符合法的是()"></a>61、下列运算符合法的是()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>B</td>
<td>&lt;&gt;</td>
</tr>
<tr>
<td>C</td>
<td>if</td>
</tr>
<tr>
<td>D</td>
<td>=</td>
</tr>
</tbody></table>
<p>答案：AD</p>
<p>分析：</p>
<ol>
<li>&amp;&amp;是逻辑运算符中的短路与</li>
<li>&lt;&gt;表示不等于，但是Java中不能这么使用，应该是!=</li>
<li>if不是运算符</li>
<li>=是赋值运算符</li>
</ol>
<h3 id="62、执行如下程序代码，c的值打印出来是"><a href="#62、执行如下程序代码，c的值打印出来是" class="headerlink" title="62、执行如下程序代码，c的值打印出来是?"></a>62、执行如下程序代码，c的值打印出来是?</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span> 
            <span class="token operator">--</span>c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先自减 c = -1</span>
            a <span class="token operator">=</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = -1</span>
        <span class="token punctuation">}</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a > 0 会一直循环</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<p>答案：-1</p>
<p>分析：do-while循环的特点是先执行后判断，所以代码先执行–c操作，得到c为-1，之后执行a=a-1的操作，得到a为-1，然后判断a是否大于0，判断条件不成立，退出循环，输出c为-1。</p>
<h3 id="63、下列哪一种叙述是正确的"><a href="#63、下列哪一种叙述是正确的" class="headerlink" title="63、下列哪一种叙述是正确的()"></a>63、下列哪一种叙述是正确的()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>abstract修饰符可修饰字段，方法和类</td>
</tr>
<tr>
<td>B</td>
<td>抽象方法的body部分必须用一对大括号{}包住</td>
</tr>
<tr>
<td>C</td>
<td>声明抽象方法，大括号可有可无</td>
</tr>
<tr>
<td>D</td>
<td>声明抽象方法不可写出大括号</td>
</tr>
</tbody></table>
<p>答案：D</p>
<p>分析：</p>
<ul>
<li>abstract只能修饰方法和类，<strong>不能修饰字段</strong>；A错</li>
<li><strong>抽象方法不能有方法体</strong>，即没有{}；B.C错</li>
</ul>
<h3 id="64、下列语句正确的是"><a href="#64、下列语句正确的是" class="headerlink" title="64、下列语句正确的是()"></a>64、下列语句正确的是()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>形式参数可被视为local Variable</td>
</tr>
<tr>
<td>B</td>
<td>形式参数可被所有的字段修饰符修饰</td>
</tr>
<tr>
<td>C</td>
<td>形式参数是方法被调用时，真正被传递的参数</td>
</tr>
<tr>
<td>D</td>
<td>形式参数不可以是对象</td>
</tr>
</tbody></table>
<p>答案：A</p>
<p>分析：</p>
<ul>
<li>local Variable为局部变量，形参和局部变量一样都只有在方法内才会发生作用，也只能在方法中使用，不会在方法外可见；</li>
<li><strong>对于形式参数只能用final修饰符</strong>，其它任何修饰符都会引起编译器错误；</li>
<li>真正被传递的参数是实参；</li>
<li><strong>形式参数可以是基本数据类型也可以是引用类型（对象）。</strong></li>
</ul>
<h3 id="65、下列哪种说法是正确的"><a href="#65、下列哪种说法是正确的" class="headerlink" title="65、下列哪种说法是正确的()"></a>65、下列哪种说法是正确的()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>实例方法可直接调用超类的实例方法</td>
</tr>
<tr>
<td>B</td>
<td>实例方法可直接调用超类的类方法</td>
</tr>
<tr>
<td>C</td>
<td>实例方法可直接调用其他类的实例方法</td>
</tr>
<tr>
<td>D</td>
<td>实例方法可直接调用本类的类方法</td>
</tr>
</tbody></table>
<p>答案：D</p>
<p>分析：</p>
<ul>
<li>超类：被继承的类一般称为“超类”，也有叫做父类。是继承中非常重要的概念，它和子类一起形象地描述了继承的层次关系</li>
<li>实例方法不可直接调用超类的私有实例方法</li>
<li>实例方法不可直接调用超类的私有的类方法</li>
<li>要看访问权限</li>
</ul>
<h3 id="66、Java程序的种类有"><a href="#66、Java程序的种类有" class="headerlink" title="66、Java程序的种类有()"></a>66、Java程序的种类有()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>类 (Class)</td>
</tr>
<tr>
<td>B</td>
<td>Applet</td>
</tr>
<tr>
<td>C</td>
<td>Application</td>
</tr>
<tr>
<td>D</td>
<td>Servlet</td>
</tr>
</tbody></table>
<p>答案：BCD</p>
<p>分析：</p>
<ul>
<li>是Java中的类，不是程序</li>
<li>内嵌于Web文件中，由浏览器来观看的Applet</li>
<li>可独立运行的 Application</li>
<li>服务器端的 Servlet</li>
</ul>
<h3 id="67、下列说法正确的有"><a href="#67、下列说法正确的有" class="headerlink" title="67、下列说法正确的有()"></a>67、下列说法正确的有()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>环境变量可在编译source code时指定</td>
</tr>
<tr>
<td>B</td>
<td>在編译程序时，所指定的环境变量不包括class path</td>
</tr>
<tr>
<td>C</td>
<td>javac —次可同时编译数个Java 源文件</td>
</tr>
<tr>
<td>D</td>
<td>javac.exe能指定编译结果要置于哪个目录（directory)</td>
</tr>
</tbody></table>
<p>答案：BCD</p>
<p>分析：</p>
<p>环境变量一般都是先配置好再编译源文件。</p>
<h3 id="68、下列标识符不合法的有"><a href="#68、下列标识符不合法的有" class="headerlink" title="68、下列标识符不合法的有()"></a>68、下列标识符不合法的有()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>new</td>
</tr>
<tr>
<td>B</td>
<td>$Usdollars</td>
</tr>
<tr>
<td>C</td>
<td>1234</td>
</tr>
<tr>
<td>D</td>
<td>car.taxi</td>
</tr>
</tbody></table>
<p>答案：ACD</p>
<p>分析：</p>
<ul>
<li>new是Java的关键字</li>
<li>C. 数字不能开头</li>
<li>D. 不能有“.” , # 这种特殊字符</li>
</ul>
<h3 id="69、下列说法错误的有"><a href="#69、下列说法错误的有" class="headerlink" title="69、下列说法错误的有()"></a>69、下列说法错误的有()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>数组是一种对象</td>
</tr>
<tr>
<td>B</td>
<td>数组属于一种原生类（基本数据类型）</td>
</tr>
<tr>
<td>C</td>
<td>int number[]=(31,23,33,43,35,63)</td>
</tr>
<tr>
<td>D</td>
<td>数组的大小可以任意改变</td>
</tr>
</tbody></table>
<p>答案：BCD</p>
<p>分析：</p>
<ul>
<li>B. Java中的原生类（即基本数据类型）有8种，但不包括数组</li>
<li>C. 语法错误，应该“{···}”，而不是“(···)”</li>
<li>D. 数组的长度一旦确定就不能修改</li>
</ul>
<h3 id="70、不能用来修饰interface的有"><a href="#70、不能用来修饰interface的有" class="headerlink" title="70、不能用来修饰interface的有()"></a>70、不能用来修饰interface的有()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>private</td>
</tr>
<tr>
<td>B</td>
<td>public</td>
</tr>
<tr>
<td>C</td>
<td>protected</td>
</tr>
<tr>
<td>D</td>
<td>static</td>
</tr>
</tbody></table>
<p>答案：ACD</p>
<p>分析：</p>
<p>能够修饰interface的只有public、abstract以及默认这三种修饰符。</p>
<h3 id="71、下列正确的有"><a href="#71、下列正确的有" class="headerlink" title="71、下列正确的有()"></a>71、下列正确的有()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>call by value不会改变实际参数的数值</td>
</tr>
<tr>
<td>B</td>
<td>call by reference能改变实际参数的参考地址</td>
</tr>
<tr>
<td>C</td>
<td>call by reference 不能改变实际参数的参考地址</td>
</tr>
<tr>
<td>D</td>
<td>call by reference 能改变实际参数的内容</td>
</tr>
</tbody></table>
<p>答案：ACD</p>
<p>分析：</p>
<ul>
<li>Java中参数的传递有两种，一种是按值传递（call by value：传递的是具体的值，如基础数据类型），另一种是按引用传递（call by reference：传递的是对象的引用，即对象的存储地址）。</li>
<li>前者不能改变实参的数值，<strong>后者虽然不能改变实参的参考地址，但可以通过该地址访问地址中的内容从而实现内容的改变。</strong></li>
</ul>
<h3 id="72、下列说法错误的有-）"><a href="#72、下列说法错误的有-）" class="headerlink" title="72、下列说法错误的有(）"></a>72、下列说法错误的有(）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>在类方法中可用this来调用本类的类方法</td>
</tr>
<tr>
<td>B</td>
<td>在类方法中调用本类的类方法时可以直接调用</td>
</tr>
<tr>
<td>C</td>
<td>在类方法中只能调用本类中的类方法</td>
</tr>
<tr>
<td>D</td>
<td>在类方法中绝对不能调用实例方法</td>
</tr>
</tbody></table>
<p>答案：ACD</p>
<p>分析：</p>
<ul>
<li>A. 类方法(Static)是在类加载时被加载到方法区存储的，此时还没有创建对象，所以不能使用this或者super关键字</li>
<li>C. 在类方法中还可以调用其他类的类方法</li>
<li>D. 在类方法可以通过创建对象来调用实例方法</li>
</ul>
<h3 id="73、下列说法错误的有"><a href="#73、下列说法错误的有" class="headerlink" title="73、下列说法错误的有()"></a>73、下列说法错误的有()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>Java面向对象语言允许单独的过程或函数存在</td>
</tr>
<tr>
<td>B</td>
<td>Java面向对象语言允许单独的方法存在</td>
</tr>
<tr>
<td>C</td>
<td>Java语言中的方法属于类中的成员（member）</td>
</tr>
<tr>
<td>D</td>
<td>Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同</td>
</tr>
</tbody></table>
<p>答案：ABC</p>
<p>分析：</p>
<ul>
<li>B. Java不允许单独的方法，过程或函数存在，需要隶属于某一类中；</li>
<li>C. <strong>静态方法属于类的成员，非静态方法属于对象的成员。</strong></li>
</ul>
<h3 id="74、下列说法错误的有"><a href="#74、下列说法错误的有" class="headerlink" title="74、下列说法错误的有()"></a>74、下列说法错误的有()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>能被java.exe成功运行的java class文件必须有main()方法</td>
</tr>
<tr>
<td>B</td>
<td>J2SDK就是Java API</td>
</tr>
<tr>
<td>C</td>
<td>Appletviewer.exe可利用jar选项运行.jar文件</td>
</tr>
<tr>
<td>D</td>
<td>能被Appletviewer成功运行的java class文件必须有main()方法</td>
</tr>
</tbody></table>
<p>答案：BCD</p>
<p>分析：</p>
<ul>
<li>B. J2SDK是sun公司编程工具，API是指的应用程序编程接口</li>
<li>C. Appletviewer.exe就是用来解释执行java applet应用程序的，一种执行HTML文件上的Java小程序类的Java浏览器</li>
<li>D. <strong>能被Appletviewer成功运行的java class文件可以没有main（）方法</strong></li>
</ul>
<h3 id="75、请问0-3332的数据类型是"><a href="#75、请问0-3332的数据类型是" class="headerlink" title="75、请问0.3332的数据类型是()"></a>75、请问0.3332的数据类型是()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>float</td>
</tr>
<tr>
<td>B</td>
<td>double</td>
</tr>
<tr>
<td>C</td>
<td>Float</td>
</tr>
<tr>
<td>D</td>
<td>Double</td>
</tr>
</tbody></table>
<p>答案：B </p>
<p>分析：小数默认是双精度浮点型即double类型的</p>
<h3 id="76、Java接口的修饰符可以为"><a href="#76、Java接口的修饰符可以为" class="headerlink" title="76、Java接口的修饰符可以为()"></a>76、Java接口的修饰符可以为()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>private</td>
</tr>
<tr>
<td>B</td>
<td>protected</td>
</tr>
<tr>
<td>C</td>
<td>final</td>
</tr>
<tr>
<td>D</td>
<td>abstract</td>
</tr>
</tbody></table>
<p>答案：D</p>
<p>分析：能够修饰interface的只有public、abstract以及默认的三种修饰符。</p>
<h3 id="77、不通过构造函数也能创建对象么"><a href="#77、不通过构造函数也能创建对象么" class="headerlink" title="77、不通过构造函数也能创建对象么()"></a>77、不通过构造函数也能创建对象么()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>可以</td>
</tr>
<tr>
<td>B</td>
<td>不可以</td>
</tr>
</tbody></table>
<p>答案：A</p>
<p>分析：</p>
<p>Java创建对象的几种方式：</p>
<ol>
<li>用new语句创建对象，这是最常见的创建对象的方法。</li>
<li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li>
<li>调用对象的clone()方法。</li>
<li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ol>
<p>(1)和(2)都会明确的显式的调用构造函数；</p>
<p><strong>(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调</strong></p>
<h3 id="78、存在使-i-1-lt-i-的数么"><a href="#78、存在使-i-1-lt-i-的数么" class="headerlink" title="78、存在使 i+1&lt;i 的数么?"></a>78、存在使 i+1&lt;i 的数么?</h3><p>答案：存在</p>
<p>分析：byte，int 等的最大值, 加1后变为负数</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">byte</span> a <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
<span class="token comment" spellcheck="true">//输出结果</span>
<span class="token number">127</span> <span class="token operator">-</span><span class="token number">128</span></code></pre>
<h3 id="79、接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"><a href="#79、接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？" class="headerlink" title="79、接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"></a>79、接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</h3><p>答案：</p>
<ul>
<li>接口可以继承接口</li>
<li>抽象类可以实现接口</li>
<li>抽象类可以继承实体类</li>
</ul>
<h3 id="80、int与Integer有什么区别？"><a href="#80、int与Integer有什么区别？" class="headerlink" title="80、int与Integer有什么区别？"></a>80、int与Integer有什么区别？</h3><ul>
<li>int是java提供的8种原始数据类型之一</li>
<li>Java为每个原始类型提供了封装类，Integer是java为int提供的封装类</li>
<li>int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别</li>
</ul>
<h2 id="81-100"><a href="#81-100" class="headerlink" title="81~100"></a>81~100</h2><h3 id="81、可序列化对象为什么要定义serialversionUID值"><a href="#81、可序列化对象为什么要定义serialversionUID值" class="headerlink" title="81、可序列化对象为什么要定义serialversionUID值?"></a>81、可序列化对象为什么要定义serialversionUID值?</h3><ul>
<li>SerialVersionUid，简言之，其目的是<strong>序列化对象版本控制</strong>，有关各版本反序列化时是否兼容。</li>
<li>如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。</li>
<li>如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改。</li>
<li>如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</li>
<li>说白了就是为了一个兼容性判断。</li>
</ul>
<h3 id="82、写一个Java正则，能过滤出html中的title中的链接地址和标题"><a href="#82、写一个Java正则，能过滤出html中的title中的链接地址和标题" class="headerlink" title="82、写一个Java正则，能过滤出html中的title中的链接地址和标题"></a>82、写一个Java正则，能过滤出html中的title中的链接地址和标题</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 哇！看不懂啊</span>
<span class="token operator">&lt;</span>a \b<span class="token punctuation">[</span><span class="token operator">^</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">+</span>\bhref<span class="token operator">=</span><span class="token string">"([^"</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">)</span>"<span class="token punctuation">[</span><span class="token operator">^</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">*</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span><span class="token operator">*</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>     </code></pre>
<p>分组1和分组2即为href和value</p>
<h3 id="83、十进制数72转换成八进制数是多少？"><a href="#83、十进制数72转换成八进制数是多少？" class="headerlink" title="83、十进制数72转换成八进制数是多少？"></a>83、十进制数72转换成八进制数是多少？</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment" spellcheck="true">//10进制转2进制</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span><span class="token number">72</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//10进制转16进制</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token number">72</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//10进制转8进制</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toOctalString</span><span class="token punctuation">(</span><span class="token number">72</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 

<span class="token comment" spellcheck="true">//输出</span>
<span class="token number">1001000</span>
<span class="token number">48</span>
<span class="token number">110</span></code></pre>
<ul>
<li><strong>十进制转2进制：</strong>Integer.toBinaryString()</li>
<li><strong>十进制转16进制：</strong>Integer.toHexString()</li>
<li><strong>十进制转8进制：</strong>Integer.toOctalString()</li>
</ul>
<h3 id="84、Java程序中创建新的类对象，使用关键字new，回收无用的类对象使用关键字free正确么？"><a href="#84、Java程序中创建新的类对象，使用关键字new，回收无用的类对象使用关键字free正确么？" class="headerlink" title="84、Java程序中创建新的类对象，使用关键字new，回收无用的类对象使用关键字free正确么？"></a>84、Java程序中创建新的类对象，使用关键字new，回收无用的类对象使用关键字free正确么？</h3><ul>
<li>Java程序中创建新的类对象，使用关键字new是正确的; 回收无用的类对象使用关键字free是错误的</li>
<li>垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）</li>
<li>程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定</li>
</ul>
<h3 id="85、Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#85、Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="85、Class类的getDeclaredFields()方法与getFields()的区别？"></a>85、Class类的getDeclaredFields()方法与getFields()的区别？</h3><ul>
<li>getDeclaredFields(): <strong>可以获取所有本类自己声明的方法, 不能获取继承的方法</strong></li>
<li>getFields(): 只能获取所有public声明的方法, 包括继承的方法</li>
</ul>
<h3 id="86、在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？"><a href="#86、在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？" class="headerlink" title="86、在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？"></a>86、在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？</h3><p>答案：不正确</p>
<p>分析：通常情况下，进行比较判断的处理，switch 和if-else可以互相转换来写；if-else作用的范围比switch-case作用范围要大，但是当switch-case和if-else都可以用的情况下，通常推荐使用switch-case。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">case</span> <span class="token string">'a'</span><span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'b'</span><span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'c'</span><span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'d'</span><span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'e'</span><span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"other"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<p>换为if-else</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'b'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'c'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'d'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'e'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Other"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="87、描述-amp-和-amp-amp-的区别"><a href="#87、描述-amp-和-amp-amp-的区别" class="headerlink" title="87、描述&amp;和&amp;&amp;的区别"></a>87、描述&amp;和&amp;&amp;的区别</h3><p><strong>&amp;和&amp;&amp;的联系(共同点)：</strong></p>
<ul>
<li><p>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定</p>
</li>
<li><p>操作数1 &amp; 操作数2，操作数1 &amp;&amp; 操作数2</p>
</li>
<li><p>表达式1 &amp; 表达式2，表达式1 &amp;&amp; 表达式2</p>
<p><strong>情况1</strong>：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p>
<p><strong>情况2</strong>：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</p>
</li>
</ul>
<p><strong>&amp;和&amp;&amp;的区别(不同点)：</strong></p>
<ol>
<li><p><strong>&amp; 称为逻辑与运算符，&amp;&amp; 称为短路与运算符，也可叫逻辑与运算符。</strong></p>
<p><strong>对于&amp;：</strong>无论任何情况，&amp;两边的操作数或表达式都会参与计算。</p>
<p><strong>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时</strong>，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</p>
<p>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。<strong>推荐平时多使用&amp;&amp;，因为它效率更高些。</strong></p>
</li>
<li><p><strong>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</strong></p>
</li>
</ol>
<h3 id="88、使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#88、使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="88、使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"></a>88、使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</h3><p>final修饰基本类型变量，其值不能改变。</p>
<p>但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。</p>
<p>例如</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">final</span> Dog dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"狗子"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"泰迪"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//正确</span>
        dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"田园犬"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//错误</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="89、请解释以下常用正则含义：-d-D-s-0-9-6-d"><a href="#89、请解释以下常用正则含义：-d-D-s-0-9-6-d" class="headerlink" title="89、请解释以下常用正则含义：\d,\D,\s,.,*,?,|,[0-9]{6},\d+"></a>89、请解释以下常用正则含义：\d,\D,\s,.,*,?,|,[0-9]{6},\d+</h3><ul>
<li>\d: 匹配一个数字字符。等价于[0-9]</li>
<li>\D: 匹配一个非数字字符。等价于^ [0-9]</li>
<li>\s: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]</li>
<li>. ：匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . </li>
<li>*：匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *</li>
<li>+：匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +</li>
<li>|:将两个匹配条件进行逻辑“或”（Or）运算</li>
<li>[0-9]{6}:匹配连续6个0-9之间的数字</li>
<li>\d+：匹配至少一个0-9之间的数字</li>
</ul>
<h3 id="90、已知表达式int-m-0-1-2-3-4-5-6-下面那个表达式的值与数组的长度相等"><a href="#90、已知表达式int-m-0-1-2-3-4-5-6-下面那个表达式的值与数组的长度相等" class="headerlink" title="90、已知表达式int m[] = {0,1,2,3,4,5,6}; 下面那个表达式的值与数组的长度相等()"></a>90、已知表达式int m[] = {0,1,2,3,4,5,6}; 下面那个表达式的值与数组的长度相等()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>m.length()</td>
</tr>
<tr>
<td>B</td>
<td>m.length</td>
</tr>
<tr>
<td>C</td>
<td>m.length() + 1</td>
</tr>
<tr>
<td>D</td>
<td>m.length + 1</td>
</tr>
</tbody></table>
<p>答案：B</p>
<p>分析：数组的长度是.length</p>
<h3 id="91、下面那些声明是合法的？"><a href="#91、下面那些声明是合法的？" class="headerlink" title="91、下面那些声明是合法的？()"></a>91、下面那些声明是合法的？()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>long l = 4990</td>
</tr>
<tr>
<td>B</td>
<td>int i = 4L</td>
</tr>
<tr>
<td>C</td>
<td>float f = 1.1</td>
</tr>
<tr>
<td>D</td>
<td>double d = 34.4</td>
</tr>
</tbody></table>
<p>答案：AD</p>
<p>分析：</p>
<ul>
<li><p>int属于整数型应该是int=4 </p>
</li>
<li><p>C应该是float f=1.1f</p>
</li>
</ul>
<h3 id="92、以下选项中选择正确的java表达式"><a href="#92、以下选项中选择正确的java表达式" class="headerlink" title="92、以下选项中选择正确的java表达式()"></a>92、以下选项中选择正确的java表达式()</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>int k=new String(“aa”)</td>
</tr>
<tr>
<td>B</td>
<td>String str = String(“bb”)</td>
</tr>
<tr>
<td>C</td>
<td>char c=74;</td>
</tr>
<tr>
<td>D</td>
<td>long j=8888;</td>
</tr>
</tbody></table>
<p>答案：CD</p>
<p>分析：</p>
<ul>
<li>A：需要强制类型转换 </li>
<li>B：String str =new String(“bb”)</li>
</ul>
<h3 id="93、下列代码的输出结果是"><a href="#93、下列代码的输出结果是" class="headerlink" title="93、下列代码的输出结果是()"></a>93、下列代码的输出结果是()</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token string">"12"</span><span class="token operator">==</span><span class="token string">"12"</span> <span class="token operator">&amp;&amp;</span> <span class="token string">"12"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"12"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> </code></pre>
<p>答案：true</p>
<p>分析：对于引用数据类型 == 比较的是地址，而 equals() 比较的是内容</p>
<h3 id="94、以下哪些运算符是含有短路运算机制的？"><a href="#94、以下哪些运算符是含有短路运算机制的？" class="headerlink" title="94、以下哪些运算符是含有短路运算机制的？"></a>94、以下哪些运算符是含有短路运算机制的？</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>&amp;</td>
</tr>
<tr>
<td>B</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>C</td>
<td>|</td>
</tr>
<tr>
<td>D</td>
<td>||</td>
</tr>
</tbody></table>
<p>答案：BD</p>
<p>分析：A C是逻辑计算</p>
<h3 id="95、下面哪个函数是public-void-example-…-的重载函数？（）"><a href="#95、下面哪个函数是public-void-example-…-的重载函数？（）" class="headerlink" title="95、下面哪个函数是public void example(){….}的重载函数？（）"></a>95、下面哪个函数是public void example(){….}的重载函数？（）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>private void example（int m）{…}</td>
</tr>
<tr>
<td>B</td>
<td>public int example（）{…}</td>
</tr>
<tr>
<td>C</td>
<td>public void example2（）{…}</td>
</tr>
<tr>
<td>D</td>
<td>public int example（int mfloat f）{…}</td>
</tr>
</tbody></table>
<p>答案：AD</p>
<p>分析：</p>
<ul>
<li>重载：方法名相同，参数不同即可</li>
<li>BC定义的是新函数</li>
</ul>
<p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/文档/笔记/笔记（未整理）/Java面试题.assets/image-20210221203815216.png" alt="image-20210221203815216" loading="lazy"></p>
<h3 id="96、给定某java程序片段，该程序运行后，j的输出结果为（）"><a href="#96、给定某java程序片段，该程序运行后，j的输出结果为（）" class="headerlink" title="96、给定某java程序片段，该程序运行后，j的输出结果为（）"></a>96、给定某java程序片段，该程序运行后，j的输出结果为（）</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2</span>
        <span class="token comment" spellcheck="true">// 2>3不成立 ,不执行if</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token operator">==</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            j<span class="token operator">+=</span>i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token comment" spellcheck="true">//输出j=2</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<p>输出 : 2</p>
<h3 id="97、在java中，无论测试条件是什么，下列（）循环将至少执行一次。"><a href="#97、在java中，无论测试条件是什么，下列（）循环将至少执行一次。" class="headerlink" title="97、在java中，无论测试条件是什么，下列（）循环将至少执行一次。"></a>97、在java中，无论测试条件是什么，下列（）循环将至少执行一次。</h3><table>
<thead>
<tr>
<th>选项</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>for</td>
</tr>
<tr>
<td>B</td>
<td>do…while</td>
</tr>
<tr>
<td>C</td>
<td>while</td>
</tr>
<tr>
<td>D</td>
<td>while…do</td>
</tr>
</tbody></table>
<p>答案：B</p>
<p>分析： ACD都不一定进行循环</p>
<h3 id="98、求函数输入结果？"><a href="#98、求函数输入结果？" class="headerlink" title="98、求函数输入结果？"></a>98、求函数输入结果？</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        Test t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> 
        <span class="token keyword">try</span> <span class="token punctuation">{</span> 
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span> 
            <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<p>最终打印结果 : 2</p>
<h3 id="99、指出下列程序的运行结果"><a href="#99、指出下列程序的运行结果" class="headerlink" title="99、指出下列程序的运行结果"></a>99、指出下列程序的运行结果</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token keyword">default</span><span class="token operator">:</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<p>输出结果 :</p>
<p>default zero</p>
<h3 id="100、解释继承、重载、覆盖"><a href="#100、解释继承、重载、覆盖" class="headerlink" title="100、解释继承、重载、覆盖"></a>100、解释继承、重载、覆盖</h3><p>继承：（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。</p>
<p>覆盖：继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。</p>
<p>重载：在一个类里面为一种行为提供多种实现方式并提高可读性。</p>
<p><img src="/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210715225852730.png" alt="image-20210715225852730" loading="lazy"></p>
<h2 id="101-120"><a href="#101-120" class="headerlink" title="101~120"></a>101~120</h2></div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">谢谢光临~</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>晓江</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/" title="java基础题">https://lxjblog.gitee.io/2021/07/15/java%E5%9F%BA%E7%A1%80%E9%A2%98/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/07/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="next" title="java知识点"><span class="post-nav-text">java知识点</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>可以直接写评论内容喔~</span><br></div><div id="valine-container"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function initValine() {
  const valineConfig = {"enable":true,"appId":"71BKFg13iJQvNsFNLGzHmK67-gzGzoHsz","appKey":"IiQx2mfEEjefvbUfSd66nBHd","placeholder":"留下你的评论呗","avatar":"robohash","pageSize":10,"visitor":false,"highlight":true,"recordIP":false,"enableQQ":true,"el":"#valine-container","lang":"zh-cn"}
  valineConfig.path = window.location.pathname
  new Valine(valineConfig)
}
setTimeout(initValine, 1000)</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2020 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 晓江</span></div><div class="live_time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-08-04T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="总访客量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="总访问量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div><script>let date = new Date();
let today = (date.getMonth() + 1) + "-" + date.getDate()
if ("4-4,9-18".indexOf(today) !== -1) {
  document.documentElement.style.filter = "grayscale(1)";
}</script><div class="aplayer no-destroy" id="aplayer" data-id="5157675042" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="random" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="1" data-listmaxheight="340px" data-storagename="metingjs"></div></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>