<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="晓江"><meta name="copyright" content="晓江"><meta name="generator" content="Hexo 5.0.0"><meta name="theme" content="hexo-theme-yun"><title>java基础题 | 云端小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.16/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_stqaphw3j4.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => <!-- hexo-inject:begin --><!-- hexo-inject:end -->{
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><link rel="shortcut icon" type="image/svg+xml" href="/icon.jpg"><link rel="mask-icon" href="/icon.jpg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><link rel="alternate" href="/atom.xml" title="云端小站" type="application/atom+xml"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"云端小站","version":"0.9.4","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"}};
  </script><meta name="description" content="Java相关基础题">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础题">
<meta property="og:url" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/index.html">
<meta property="og:site_name" content="云端小站">
<meta property="og:description" content="Java相关基础题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112193743042.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112201046032.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112201955694.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221195639080.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221200952693.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221203556441.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221203815216.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210222113759020.png">
<meta property="og:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210222114959881.png">
<meta property="article:published_time" content="2021-02-22T05:45:35.000Z">
<meta property="article:modified_time" content="2021-02-22T05:46:49.508Z">
<meta property="article:author" content="晓江">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112193743042.png"><script src="/js/ui/mode.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="晓江"><img width="96" loading="lazy" src="/icon.jpg" alt="晓江"></a><div class="site-author-name"><a href="/about/">晓江</a></div><a class="site-name" href="/about/site.html">云端小站</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">40</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">15</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">44</span></a></div><a class="site-state-item hty-icon-button" href="https://lxjblog.gitee.io/myblog" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/wechat/" title="微信" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1256240778&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Xiaojiang-l" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/playlist?id=5157675042" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:1256240778@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-text">Java面试题总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-20"><span class="toc-text">1~20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="toc-text">1、Java跨平台原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Java%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">2、Java的安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Java%E4%B8%89%E5%A4%A7%E7%89%88%E6%9C%AC"><span class="toc-text">3、Java三大版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJVM%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFJDK%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFJRE%EF%BC%9F"><span class="toc-text">4、什么是JVM？什么是JDK？什么是JRE？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Java%E4%B8%89%E7%A7%8D%E6%B3%A8%E9%87%8A%E7%B1%BB%E5%9E%8B"><span class="toc-text">5、Java三种注释类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-text">6、八种基本数据类型及其字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81i-%E5%92%8C-i%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-text">7、i++和++i的异同之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81-amp-%E5%92%8C-amp-amp-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">8、 &amp;和&amp;&amp; , |和|| 的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="toc-text">9、用最有效率的方法算出2乘以8等于多少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-text">10、基本数据类型的类型转换规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81if%E5%92%8Cswitch%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-text">11、if和switch的异同之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81while%E5%92%8Cdo-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12、while和do-while循环的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81break%E5%92%8Ccontinue%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">13、break和continue的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E8%AF%B7%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97n%EF%BC%81"><span class="toc-text">14、请使用递归算法计算n！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">15、递归的定义和优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">16、数组的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81"><span class="toc-text">17、请写出冒泡排序代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">18、请写出选择排序的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">19、请写出插入排序的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-text">20、可变参数的作用和特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-40"><span class="toc-text">21~40</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">21、类和对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">22、面向过程和面向对象的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81-this%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">23、 this和super关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">24、static关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81final%E5%92%8Cabstract%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">25、final和abstract关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">26、final、finally、finalize的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E5%86%99%E5%87%BAjava-lang-Object%E7%B1%BB%E7%9A%84%E5%85%AD%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">27、写出java.lang.Object类的六个常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">28、权限修饰符的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81%E7%BB%A7%E6%89%BF%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">29、继承条件下构造方法的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">30、&#x3D;&#x3D;和equals的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E8%B0%88%E8%B0%88Java%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">31、谈谈Java的多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E7%AE%80%E8%BF%B0Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">32、简述Java的垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">33、基本数据类型和包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81Integer%E4%B8%8Eint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">34、Integer与int的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81java-sql-Date%E5%92%8Cjava-util-Date%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">35、java.sql.Date和java.util.Date的联系和区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81%E9%80%92%E5%BD%92%E5%BA%94%E7%94%A8%E9%A2%98"><span class="toc-text">36、递归应用题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81%E5%85%B3%E4%BA%8EJava%E7%BC%96%E8%AF%91%EF%BC%8C%E4%B8%8B%E9%9D%A2%E5%93%AA%E4%B8%80%E4%B8%AA%E6%AD%A3%E7%A1%AE%EF%BC%88%EF%BC%89"><span class="toc-text">37、关于Java编译，下面哪一个正确（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%9C%89%EF%BC%88%EF%BC%89"><span class="toc-text">38、下列说法正确的有（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81Java%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E4%BB%A5%E4%B8%BA%EF%BC%88%EF%BC%89"><span class="toc-text">39、Java中接口的修饰符可以为（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81%E7%BB%99%E5%AE%9A%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%B0%86%E8%BE%93%E5%87%BA-%EF%BC%88%EF%BC%89"><span class="toc-text">40、给定以下代码，程序将输出 （）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-60"><span class="toc-text">41~60</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="晓江"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="云端小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">java基础题</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-02-22 13:45:35" itemprop="dateCreated datePublished" datetime="2021-02-22T13:45:35+08:00">2021-02-22</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/java%E5%9F%BA%E7%A1%80/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">java基础</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/java/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://www.gravatar.com/avatar/e5f5f8c0a25752c0deb58c83ad143e37?s=20&amp;d=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2FYunYouJun%2Fcdn%2Fimg%2Favatar%2Fnone.jpg"></div><span class="author-name">晓江</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="Java面试题总结"><a href="#Java面试题总结" class="headerlink" title="Java面试题总结"></a>Java面试题总结</h2><h2 id="1-20"><a href="#1-20" class="headerlink" title="1~20"></a>1~20</h2><h3 id="1、Java跨平台原理"><a href="#1、Java跨平台原理" class="headerlink" title="1、Java跨平台原理"></a>1、Java跨平台原理</h3><blockquote>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>字节码文件、虚拟机</p>
</blockquote>
<ul>
<li>C/C++语言都直接编译成针对特定平台机器码，如果要跨平台，需要使用相应的编译重新编译。</li>
<li>Java源程序（.java）要先编译成与平台无关的字节码文件（.class），然后字节码文件在解释成机器码运行，Java虚拟机来执行。</li>
<li>字节码文件不面向任何具体平台，只面向虚拟机。</li>
<li>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</li>
<li>Java语言具有一次编译，到处运行的特点，就是说编译后的.class文件可以跨平台运行，前提是该平台具有相应的Java虚拟机，但是性能比C/C++要低。</li>
<li>Java的跨平台原理决定其性能没有C/C++高。</li>
</ul>
<p><img src="/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112193743042.png" alt="image-20210112193743042" loading="lazy"></p>
<h3 id="2、Java的安全性"><a href="#2、Java的安全性" class="headerlink" title="2、Java的安全性"></a>2、Java的安全性</h3><blockquote>
<p>语言层次</p>
</blockquote>
<p><strong>Java取消了强大但又危险的指针</strong>，而代之为引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</p>
<blockquote>
<p>垃圾回收机制</p>
</blockquote>
<p><strong>不需要程序员直接控制内存回收</strong>，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄漏。避免程序错误回收程序核心类库的内存，导致系统崩溃。</p>
<blockquote>
<p>异常处理机制</p>
</blockquote>
<p>Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</p>
<blockquote>
<p>强制类型转换</p>
</blockquote>
<p>只有在满足强制转换规则的情况下才能强转成功。</p>
<blockquote>
<p>底层的安全性</p>
</blockquote>
<ul>
<li><p>Java在字节码的传输过程中使用了公开密钥加密机制（PKC）</p>
</li>
<li><p>在运行环境提供了四级安全性保障机制：</p>
<p>字节码校验器 - 类装载器 - 运行时内存布局 - 文件访问权限</p>
</li>
</ul>
<h3 id="3、Java三大版本"><a href="#3、Java三大版本" class="headerlink" title="3、Java三大版本"></a>3、Java三大版本</h3><p><strong>Java平台包括标准版（J2SE）、企业版（J2EE）和微压缩版（J2ME）三个版本：</strong></p>
<ul>
<li><p><strong>Standard Edition(标准版)</strong> J2SE 包含那些构成Java语言核心的类。</p>
<p>比如：数据库连接、接口定义、输入/输出、网络编程</p>
</li>
<li><p><strong>Enterprise Edition(企业版)</strong> J2EE 包含J2SE 中的类，并且还包含用于开发企业级应用的类。</p>
<p>比如servlet、JSP、XML、事务控制</p>
</li>
<li><p><strong>Micro Edition(微缩版)</strong> J2ME 包含J2SE中一部分类，用于消费类电子产品的软件开发。</p>
<p>比如：呼机、智能卡、手机、PDA、机顶盒</p>
</li>
</ul>
<p><strong>他们的范围是：</strong><br>J2SE包含于J2EE中，J2ME包含了J2SE的核心类，但新添加了一些专有类应用场合，API的覆盖范围各不相同。</p>
<h3 id="4、什么是JVM？什么是JDK？什么是JRE？"><a href="#4、什么是JVM？什么是JDK？什么是JRE？" class="headerlink" title="4、什么是JVM？什么是JDK？什么是JRE？"></a>4、什么是JVM？什么是JDK？什么是JRE？</h3><blockquote>
<p>JVM</p>
</blockquote>
<p><strong>JVM是Java Virtual Machine（Java虚拟机）的缩写</strong>，它是整个Java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。<strong>JVM是Java平台的基础</strong>，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 <strong>JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。</strong>JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。</p>
<blockquote>
<p>JRE</p>
</blockquote>
<p><strong>JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行</strong>，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib，<strong>在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和lib和起来就称为jre</strong>。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。<strong>JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的</strong>（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。</p>
<blockquote>
<p>JDK</p>
</blockquote>
<p><strong>JDK是java development kit（java开发工具包）的缩写。</strong>每个学java的人都会先在机器上装一个JDK，那让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。</p>
<ul>
<li><strong>bin:</strong> 最主要的是编译器(javac.exe)</li>
<li><strong>include:</strong> java和JVM交互用的头文件</li>
<li><strong>lib：</strong>类库</li>
<li><strong>jre:</strong> java运行环境</li>
</ul>
<p>（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）<br>总的来说<strong>JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能</strong>。eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。</p>
<blockquote>
<p>JDK、JRE、JVM三者关系概括如下：</p>
</blockquote>
<ul>
<li>JDK是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。</li>
<li>JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。</li>
<li>JDK、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li>
</ul>
<h3 id="5、Java三种注释类型"><a href="#5、Java三种注释类型" class="headerlink" title="5、Java三种注释类型"></a>5、Java三种注释类型</h3><p>共有单行注释、多行注释、文档注释3种注释类型。</p>
<ul>
<li><p><strong>单行注释，采用<code>//</code>方式.只能注释一行代码。如：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 类成员变量</span></code></pre>
</li>
<li><p><strong>多行注释，采用<code>/*...*/</code>方式，可注释多行代码，其中不允许出现嵌套。如：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
System.out.println("a");
System.out.println("b");
System.out.println("c");
*/</span></code></pre>
</li>
<li><p>文档注释，采用<code>/**...*/</code>方式，如：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
* @author 晓江
* @descripted QQ:1256240778 
*/</span></code></pre>
</li>
</ul>
<h3 id="6、八种基本数据类型及其字节数"><a href="#6、八种基本数据类型及其字节数" class="headerlink" title="6、八种基本数据类型及其字节数"></a>6、八种基本数据类型及其字节数</h3><p><img src="/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112201046032.png" alt="image-20210112201046032" loading="lazy"></p>
<h3 id="7、i-和-i的异同之处"><a href="#7、i-和-i的异同之处" class="headerlink" title="7、i++和++i的异同之处"></a>7、i++和++i的异同之处</h3><p><strong>共同点：</strong></p>
<ol>
<li><p>i++和++i都是变量自增1，都等价于i=i+1</p>
</li>
<li><p>如果i++,++i是一条单独的语句，两者没有任何区别</p>
</li>
<li><p>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</p>
</li>
</ol>
<p><strong>不同点：</strong></p>
<ul>
<li>如果i++,++i不是一条单独的语句，他们就有区别<br>i++ ：先运算后增1。</li>
<li>++i ： 先增1后运算</li>
</ul>
<h3 id="8、-amp-和-amp-amp-和-的区别和联系"><a href="#8、-amp-和-amp-amp-和-的区别和联系" class="headerlink" title="8、 &amp;和&amp;&amp; , |和|| 的区别和联系"></a>8、 &amp;和&amp;&amp; , |和|| 的区别和联系</h3><p><strong>&amp;和&amp;&amp;的联系(共同点)：</strong></p>
<ul>
<li><p>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定</p>
</li>
<li><p>操作数1 &amp; 操作数2，操作数1 &amp;&amp; 操作数2</p>
</li>
<li><p>表达式1 &amp; 表达式2，表达式1 &amp;&amp; 表达式2</p>
<p><strong>情况1</strong>：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p>
<p><strong>情况2</strong>：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</p>
</li>
</ul>
<p><strong>&amp;和&amp;&amp;的区别(不同点)：</strong></p>
<ol>
<li><p><strong>&amp; 称为逻辑与运算符，&amp;&amp; 称为短路与运算符，也可叫逻辑与运算符。</strong></p>
<p><strong>对于&amp;：</strong>无论任何情况，&amp;两边的操作数或表达式都会参与计算。</p>
<p><strong>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时</strong>，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</p>
<p>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。<strong>推荐平时多使用&amp;&amp;，因为它效率更高些。</strong></p>
</li>
<li><p><strong>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</strong></p>
</li>
</ol>
<p>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</p>
<h3 id="9、用最有效率的方法算出2乘以8等于多少"><a href="#9、用最有效率的方法算出2乘以8等于多少" class="headerlink" title="9、用最有效率的方法算出2乘以8等于多少"></a>9、用最有效率的方法算出2乘以8等于多少</h3><ul>
<li>使用位运算来实现效率最高。<strong>位运算符是对操作数以二进制比特位为单位进行操作和运算</strong>，操作数和结果都是整型数。</li>
<li><strong>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方</strong>，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高。所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3</li>
</ul>
<h3 id="10、基本数据类型的类型转换规则"><a href="#10、基本数据类型的类型转换规则" class="headerlink" title="10、基本数据类型的类型转换规则"></a>10、基本数据类型的类型转换规则</h3><blockquote>
<p>基本类型转换分为自动转换和强制转换。</p>
</blockquote>
<ul>
<li><p><strong>自动转换规则：</strong><br><strong>容量小的数据类型可以自动转换成容量大的数据类型</strong>，也可以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的范围。</p>
<p><img src="/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210112201955694.png" alt="image-20210112201955694" loading="lazy"></p>
</li>
<li><p><strong>强制转换规则：</strong></p>
<p>高级变为低级需要强制转换：</p>
<ol>
<li>赋值运算符“=”右边的转换，<strong>先自动转换成表达式中级别最高的数据类型</strong>，再进行运算。</li>
<li>赋值运算符“=”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 == 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</li>
<li><strong>可以将整型常量直接赋值给byte, short, char等类型变量</strong>，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</li>
</ol>
</li>
</ul>
<h3 id="11、if和switch的异同之处"><a href="#11、if和switch的异同之处" class="headerlink" title="11、if和switch的异同之处"></a>11、if和switch的异同之处</h3><ul>
<li><p><strong>相同之处：</strong></p>
<p>都是分支语句，对超过一种的情况进行判断处理。</p>
</li>
<li><p><strong>不同之处：</strong><br>switch更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有break跳出），不加判断地执行下去; 而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。<strong>switch为等值判断（不允许比如&gt;= &lt;=），而if为等值和区间都可以，if的使用范围大。</strong></p>
</li>
</ul>
<h3 id="12、while和do-while循环的区别"><a href="#12、while和do-while循环的区别" class="headerlink" title="12、while和do-while循环的区别"></a>12、while和do-while循环的区别</h3><ul>
<li>while先判断后执行，第一次判断为false , 循环体一次都不执行。 do while先执行后判断，最少执行1次。</li>
<li>如果while循环第一次判断为true, 则两种循环没有区别。</li>
</ul>
<h3 id="13、break和continue的作用"><a href="#13、break和continue的作用" class="headerlink" title="13、break和continue的作用"></a>13、break和continue的作用</h3><ul>
<li>break: 结束当前循环并退出当前循环体。break还可以退出switch语句</li>
<li>continue: 当前循环中后续的语句不执行，但是循环体没有结束，继续进行循环条件的判断（for循环还会i++）。 continue只是结束本次循环。</li>
</ul>
<h3 id="14、请使用递归算法计算n！"><a href="#14、请使用递归算法计算n！" class="headerlink" title="14、请使用递归算法计算n！"></a>14、请使用递归算法计算n！</h3><blockquote>
<p>Recursion 读法:[rɪˈkɜ:rʃn] 递归</p>
</blockquote>
<p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。 自然数n的阶乘写作n!。 1808年，基斯顿·卡曼引进这个表示法。 亦即n!=1×2×3×…×n。阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Recursion</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">//阶乘算法</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span> 
            <span class="token keyword">return</span> num<span class="token operator">*</span><span class="token function">factorial</span><span class="token punctuation">(</span>num<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        Recursion recursion <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Recursion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> factorial <span class="token operator">=</span> recursion<span class="token punctuation">.</span><span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>factorial<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="15、递归的定义和优缺点"><a href="#15、递归的定义和优缺点" class="headerlink" title="15、递归的定义和优缺点"></a>15、递归的定义和优缺点</h3><blockquote>
<p><strong>递归算法是一种直接或者间接地调用自身算法的过程。</strong>在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</p>
</blockquote>
<p><strong>递归算法解决问题的特点：</strong></p>
<ol>
<li>递归就是在过程或函数里调用自身。</li>
<li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
<li>递归算法解题通常显得很简洁，但<strong>运行效率较低，所以一般不提倡用递归算法设计程序。</strong></li>
<li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。<strong>递归次数过多容易造成栈溢出等</strong>。所以一般不提倡用递归算法设计程序。</li>
</ol>
<h3 id="16、数组的特征"><a href="#16、数组的特征" class="headerlink" title="16、数组的特征"></a>16、数组的特征</h3><blockquote>
<p>数组是（相同类型数据）的（有序）（集合）</p>
</blockquote>
<p>数组会在内存中开辟一块连续的空间，每个空间相当于之前的一个变量，称为数组的元素element</p>
<p>元素的表示：数组名[下标或者索引] <code>scores[7] scores[0] scores[9]</code>，索引从0开始</p>
<p>每个数组元素有默认值 <code>double 0.0; boolean false; int 0</code></p>
<p>数组元素有序的，不是大小顺序，是索引的顺序</p>
<p>数组中可以存储基本数据类型，可以存储引用数据类型；但是对于一个数组而言，数组的类型是固定的，只能是一个length:数组的长度</p>
<p>数组的长度是固定的，一经定义，不能再发生变化（数组的扩容）</p>
<h3 id="17、请写出冒泡排序代码"><a href="#17、请写出冒泡排序代码" class="headerlink" title="17、请写出冒泡排序代码"></a>17、请写出冒泡排序代码</h3><blockquote>
<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。</p>
</blockquote>
<p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。</p>
<p>走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
<p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<p><strong>冒泡排序算法的原理如下：</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221195639080.png" alt="image-20210221195639080" loading="lazy"></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bubble</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 外层循环，它决定一共走几趟 //-1为了防止溢出</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//通过符号位可以减少无谓的比较，如果已经有序了，就退出循环</span>
            <span class="token comment" spellcheck="true">//内层循环，它决定每趟走一次</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                <span class="token comment" spellcheck="true">//如果后一个大于前一个,则换位</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                    temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                    flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> 
            <span class="token punctuation">}</span> 
            <span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span> 
        <span class="token keyword">return</span> array<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        Bubble bubble <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bubble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sort <span class="token operator">=</span> bubble<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span>sort<span class="token punctuation">)</span><span class="token punctuation">{</span> 
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="18、请写出选择排序的代码"><a href="#18、请写出选择排序的代码" class="headerlink" title="18、请写出选择排序的代码"></a>18、请写出选择排序的代码</h3><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法。</p>
<p><img src="/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221200952693.png" alt="image-20210221200952693" loading="lazy"></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectSort</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token comment" spellcheck="true">// 认为目前的数就是最小的, 记录最小数的下标</span>
            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                    <span class="token comment" spellcheck="true">// 修改最小值的下标</span>
                    minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> 
            <span class="token punctuation">}</span> 
            <span class="token comment" spellcheck="true">// 当退出for就找到这次的最小值,就需要交换位置了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> minIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                <span class="token comment" spellcheck="true">//交换当前值和找到的最小值的位置</span>
                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span> 
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        SelectSort selectSort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SelectSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sort <span class="token operator">=</span> selectSort<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span>sort<span class="token punctuation">)</span><span class="token punctuation">{</span> 
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="19、请写出插入排序的代码"><a href="#19、请写出插入排序的代码" class="headerlink" title="19、请写出插入排序的代码"></a>19、请写出插入排序的代码</h3><blockquote>
<p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法。</p>
</blockquote>
<p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。</p>
<p>插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
<p><strong>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</strong>包括：<strong>直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）</strong>。属于稳定排序的一种（通俗地讲，就是两个相等的数不会交换位置）。</p>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li><p>从第一个元素开始，该元素可以认为已经被排序 </p>
</li>
<li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描 </p>
</li>
<li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置 </p>
</li>
<li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 </p>
</li>
<li><p>将新元素插入到下一位置中 </p>
</li>
<li><p>重复步骤2~5</p>
</li>
</ol>
<p><strong>如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。</strong>该算法可以认为是插入排序的一个变种，称为二分查找排序。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token punctuation">{</span> 
    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token comment" spellcheck="true">//如果传入的数组为空或者只有一个值,就直接返回</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token comment" spellcheck="true">//不为空则进循环判断</span>
        <span class="token comment" spellcheck="true">//外层循环控制总数量</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token comment" spellcheck="true">//内层循环依次减少并提出结果</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
                <span class="token comment" spellcheck="true">//如果当前数字小于前一个,则交换,否则不变</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
                    <span class="token keyword">int</span> temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span> 
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> 
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span> 
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        InsertSort insertSort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InsertSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sort <span class="token operator">=</span> insertSort<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span>sort<span class="token punctuation">)</span><span class="token punctuation">{</span> 
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="20、可变参数的作用和特点"><a href="#20、可变参数的作用和特点" class="headerlink" title="20、可变参数的作用和特点"></a>20、可变参数的作用和特点</h3><p>详解 : <a target="_blank" rel="noopener" href="https://www.cnblogs.com/uptownBoy/articles/1698335.html">https://www.cnblogs.com/uptownBoy/articles/1698335.html</a></p>
<blockquote>
<p>总结1：</p>
</blockquote>
<ol>
<li><p>可变参数的形式 …</p>
</li>
<li><p>可变参数只能是方法的形参</p>
</li>
<li><p>可变参数对应的实参可以0,1,2…..n个，也可以是一个数组</p>
</li>
<li><p>在可变参数的方法中，将可变参数当做数组来处理</p>
</li>
<li><p>可变参数最多有一个，只能是最后一个</p>
</li>
<li><p>可变参数好处：方便 简单 减少重载方法的数量</p>
</li>
<li><p>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</p>
</li>
</ol>
<blockquote>
<p>总结2： 数组做形参和可变参数做形参联系和区别</p>
</blockquote>
<p><strong>联系：</strong></p>
<ol>
<li>实参都可以是数组；</li>
<li>方法体中，可变参数本质就是当做数组来处理</li>
</ol>
<p><strong>区别：</strong></p>
<ol>
<li><p>个数不同 可变参数只能有一个数组参数可以多个</p>
</li>
<li><p>位置不同 可变参数只能是最后一个 数组参数位置任意</p>
</li>
<li><p>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</p>
</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 指定类型的参数</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        sum <span class="token operator">+=</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span> </code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通用类型参数</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintfSample</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token function">printOut</span><span class="token punctuation">(</span><span class="token string">"Pi:%f E:%f\n"</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>PI<span class="token punctuation">,</span> Math<span class="token punctuation">.</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printOut</span><span class="token punctuation">(</span>String format<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h2 id="21-40"><a href="#21-40" class="headerlink" title="21~40"></a>21~40</h2><h3 id="21、类和对象的关系"><a href="#21、类和对象的关系" class="headerlink" title="21、类和对象的关系"></a>21、类和对象的关系</h3><p><strong>类是对象的抽象，而对象是类的具体实例。</strong> 类是抽象的，不占用内存，而对象是具体的，占用存储空间。 类是用于创建对象的蓝图，类就是一个带方法和变量的特定类型。</p>
<p>类和对象好比图纸和实物的关系，模具和铸件的关系。</p>
<p>比如人类就是一个概念，人类具有身高，体重等属性。人类可以做吃饭、说话等方法。</p>
<p>小明就是一个具体的人，也就是实例，他的属性是具体的身高200cm，体重180kg，他做的方法是具体的吃了一碗白米饭，说了“12345”这样一句话。</p>
<p>还可以有小红,小蓝等具体的人即对象,但他们都是人类的实例,即类.</p>
<h3 id="22、面向过程和面向对象的区别"><a href="#22、面向过程和面向对象的区别" class="headerlink" title="22、面向过程和面向对象的区别"></a>22、面向过程和面向对象的区别</h3><p>两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。</p>
<p><img src="/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221203556441.png" alt="image-20210221203556441" loading="lazy"></p>
<p><strong>比喻:</strong></p>
<p>面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。蛋炒饭就不行了, 如果不满意就要丢掉重做;</p>
<blockquote>
<p>区别:</p>
</blockquote>
<p><strong>编程思路不同：</strong> 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</p>
<p><strong>封装性：</strong>都具有封装性，<strong>但是面向过程封装的是功能，而面向对象封装的是数据和功能</strong>。面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</p>
<p><strong>方法重载和方法重写（覆盖）的区别:</strong></p>
<p><img src="/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210221203815216.png" alt="image-20210221203815216" loading="lazy"></p>
<h3 id="23、-this和super关键字的作用"><a href="#23、-this和super关键字的作用" class="headerlink" title="23、 this和super关键字的作用"></a>23、 this和super关键字的作用</h3><p>this是对象内部指代自身的引用，同时也是解决成员变量和局部变量同名问题；this可以调用成员变量，不能调用局部变量；this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句。而且在静态方法当中不允许出现this关键字。</p>
<p>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员）</p>
<p>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</p>
<h3 id="24、static关键字的作用"><a href="#24、static关键字的作用" class="headerlink" title="24、static关键字的作用"></a>24、static关键字的作用</h3><p><strong>static可以修饰变量、方法、代码块和内部类。</strong></p>
<p>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过<code>对象名.属性名</code>和<code>类名.属性名</code>两种方式来访问。也可以在没有创建任何对象之前通过<code>类名.属性名</code>的方式来访问。</p>
<p>.static变量和非static变量的区别(都是成员变量，不是局部变量)</p>
<p><strong>1、在内存中份数不同</strong></p>
<p>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份。<strong>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量。</strong></p>
<p><strong>2、在内存中存放的位置不同</strong></p>
<p>静态变量存在方法区中， 实例变量存在堆内存中</p>
<p><img src="/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210222113759020.png" alt="image-20210222113759020" loading="lazy"></p>
<p><strong>3、访问的方式不同</strong></p>
<ul>
<li><strong>实例变量</strong>： 对象名.变量名 stu1.name=”小明明”;</li>
<li><strong>静态变量</strong>：对象名.变量名 stu1.schoolName=”西二旗小学”; 不推荐如此使用<br>类名.变量名 Student.schoolName=”东三旗小学”; 推荐使用</li>
</ul>
<p><strong>4、在内存中分配空间的时间不同</strong></p>
<ul>
<li>实例变量：创建对象的时候才分配了空间。</li>
<li>静态变量：第一次使用类的时候</li>
</ul>
<p>Student.schoolName=”东三旗小学”;或者Student stu1 = new Student(“小明”,”男”,20,98);</p>
<p>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</p>
<p>static代码块，当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</p>
<p><strong>static内部类</strong>：属于整个外部类，而不是属于外部类的每个对象。<strong>不能访问外部类的非静态成员（变量或者方法），可以访问外部类的静态成员。</strong></p>
<h3 id="25、final和abstract关键字的作用"><a href="#25、final和abstract关键字的作用" class="headerlink" title="25、final和abstract关键字的作用"></a>25、final和abstract关键字的作用</h3><blockquote>
<p>final和abstract是功能相反的两个关键字，可以对比记忆</p>
</blockquote>
<p><strong>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；</strong>使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</p>
<p><strong>final可以用来修饰类、方法和属性，不能修饰构造方法。</strong>使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。</p>
<p>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；<strong>但是final修饰引用类型变量</strong>，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">final</span> People people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"大黄"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//正确</span>
        people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">"大黄"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//错误</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="26、final、finally、finalize的区别"><a href="#26、final、finally、finalize的区别" class="headerlink" title="26、final、finally、finalize的区别"></a>26、final、finally、finalize的区别</h3><p><strong>final修饰符(关键字)如果一个类被声明为final</strong>，意味着它不能再派生出新的子类，不能作为父类被继承例如：String类、Math类等。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为<strong>final的方法也同样只能使用，不能重写，但是能够重载</strong>。使用final修饰的对象，对象的引用地址不能变，但是对象的值可以变!</p>
<p><strong>finally在异常处理时提供 finally 块来执行任何清除操作</strong>。如果有finally的话，则不管是否发生异常，finally语句都会被执行。一般情况下，都把关闭物理连接(IO流、数据库连接、Socket连接)等相关操作，放入到此代码块中。</p>
<p><strong>finalize方法名</strong>。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作。<strong>finalize() 方法是在垃圾收集器删除对象之前被调用的</strong>。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。 一般情况下，此方法由JVM调用，程序员不要去调用!</p>
<h3 id="27、写出java-lang-Object类的六个常用方法"><a href="#27、写出java-lang-Object类的六个常用方法" class="headerlink" title="27、写出java.lang.Object类的六个常用方法"></a>27、写出java.lang.Object类的六个常用方法</h3><p>(1)public boolean <strong>equals</strong>(java.lang.Object)比较对象的地址值是否相等，如果子类重写，则比较对象的内容是否相等；</p>
<p>(2)public native int <strong>hashCode</strong>() 获取哈希码</p>
<p>(3)public java.lang.String <strong>toString</strong>() 把数据转变成字符串</p>
<p>(4)public final native java.lang.Class <strong>getClass</strong>() 获取类结构信息</p>
<p>(5)protected void <strong>finalize</strong>() throws java.lang.Throwable垃圾回收前执行的方法</p>
<p>(6)protected native Object <strong>clone</strong>() throws java.lang.CloneNotSupportedException 克隆</p>
<p>(7)public final void <strong>wait</strong>() throws java.lang.InterruptedException多线程中等待功能</p>
<p>(8)public final native void <strong>notify</strong>() 多线程中唤醒功能</p>
<p>(9)public final native void <strong>notifyAll</strong>() 多线程中唤醒所有等待线程的功能</p>
<h3 id="28、权限修饰符的区别"><a href="#28、权限修饰符的区别" class="headerlink" title="28、权限修饰符的区别"></a>28、权限修饰符的区别</h3><p><img src="/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/image-20210222114959881.png" alt="image-20210222114959881" loading="lazy"></p>
<p><strong>类的访问权限只有两种:</strong></p>
<ul>
<li><strong>public</strong> 公共的 可被同一项目中所有的类访问。 (必须与文件名同名)</li>
<li><strong>default</strong> 默认的 可被同一个包中的类访问。</li>
</ul>
<p><strong>成员(成员变量或成员方法)访问权限共有四种：</strong></p>
<ul>
<li><strong>public</strong> 公共的 可以被项目中所有的类访问。(项目可见性)</li>
<li><strong>protected</strong> 受保护的 可以被这个类本身访问;同一个包中的所有其他的类访问;被它的子类(同一个包以及不同包中的子类)访问。(子类可见性)</li>
<li><strong>default</strong> 默认的被这个类本身访问;被同一个包中的类访问。(包可见性)</li>
<li><strong>private</strong> 私有的 只能被这个类本身访问。(类可见性)</li>
</ul>
<h3 id="29、继承条件下构造方法的执行过程"><a href="#29、继承条件下构造方法的执行过程" class="headerlink" title="29、继承条件下构造方法的执行过程"></a>29、继承条件下构造方法的执行过程</h3><p><strong>继承条件下构造方法的调用规则如下：</strong></p>
<ul>
<li><strong>情况1</strong>：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</li>
<li><strong>情况2</strong>：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</li>
<li><strong>情况3</strong>：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</li>
</ul>
<h3 id="30、-和equals的区别和联系"><a href="#30、-和equals的区别和联系" class="headerlink" title="30、==和equals的区别和联系"></a>30、==和equals的区别和联系</h3><blockquote>
<p>“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</p>
</blockquote>
<p><strong>“==”使用情况如下：</strong></p>
<ol>
<li>基本类型，比较的是值</li>
<li>引用类型，比较的是地址</li>
<li>不能比较没有父子关系的两个对象</li>
</ol>
<p><strong>equals()方法使用如下：</strong></p>
<ol>
<li><strong>系统类一般已经覆盖了equals()，比较的是内容。</strong></li>
<li>用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址（return (this == obj);）</li>
<li>用户自定义类需要覆盖父类的equals()</li>
</ol>
<p><strong>注意：Object的==和equals比较的都是地址，作用相同</strong></p>
<h3 id="31、谈谈Java的多态"><a href="#31、谈谈Java的多态" class="headerlink" title="31、谈谈Java的多态"></a>31、谈谈Java的多态</h3><p>多态性是OOP中的一个重要特性，主要是用来实现动态联编的，换句话说，就是程序的最终状态只有在执行过程中才被决定而非在编译期间就决定了。这对于大型系统来说能提高系统的灵活性和扩展性。</p>
<p>多态可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，从而实现更加灵活的编程，提高系统的可扩展性。</p>
<p><strong>实现多态的三个条件（前提条件，向上转型、向下转型）</strong></p>
<ol>
<li>继承的存在（继承是多态的基础，没有继承就没有多态）</li>
<li>子类重写父类的方法（多态下会调用子类重写后的方法）</li>
<li>父类引用变量指向子类对象（涉及子类到父类的类型转换）</li>
</ol>
<p><strong>向上转型 Animal a = new Cat();</strong></p>
<p>​    <strong>将一个父类的引用指向一个子类对象，称为向上转型</strong>，自动进行类型转换。此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法,此时通过父类引用变量无法调用子类特有的方法。</p>
<p><strong>向下转型 Cat a2 = (Cat)a;</strong></p>
<p>​    将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。<strong>向下转型必须转换为父类引用指向的真实子类类型</strong>，否则将出现ClassCastException，不是任意的强制转换。</p>
<p>​    向下转型时可以结合使用instanceof运算符进行强制类型转换，比如出现转换异常–ClassCastException.比如：本来是狗，我把它转成猫。就会报这个异常。</p>
<h3 id="32、简述Java的垃圾回收机制"><a href="#32、简述Java的垃圾回收机制" class="headerlink" title="32、简述Java的垃圾回收机制"></a>32、简述Java的垃圾回收机制</h3><p>传统的C/C++语言，需要程序员负责回收已经分配内存。</p>
<blockquote>
<p>显式回收垃圾</p>
</blockquote>
<p><strong>显式回收垃圾回收的缺点：</strong></p>
<ol>
<li>程序忘记及时回收，从而导致内存泄露，降低系统性能。</li>
<li>程序错误回收程序核心类库的内存，导致系统崩溃。</li>
</ol>
<p><strong>Java语言不需要程序员直接控制内存回收，是由JRE在后台自动回收不再使用的内存，称为垃圾回收机制，简称GC；</strong></p>
<ol>
<li>可以提高编程效率。</li>
<li>保护程序的完整性。</li>
<li>其开销影响性能。Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。</li>
</ol>
<blockquote>
<p>垃圾回收机制</p>
</blockquote>
<p><strong>垃圾回收机制的特点:</strong></p>
<ol>
<li>垃圾回收机制回收JVM堆内存里的对象空间,不负责回收栈内存数据。</li>
<li>对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。</li>
<li>垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。</li>
<li>可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。</li>
</ol>
<p><strong>现在的JVM有多种垃圾回收实现算法，表现各异。</strong></p>
<p>垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。</p>
<p>程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。</p>
<p>永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</p>
<h3 id="33、基本数据类型和包装类"><a href="#33、基本数据类型和包装类" class="headerlink" title="33、基本数据类型和包装类"></a>33、基本数据类型和包装类</h3><p><strong>1、八个基本数据类型的包装类</strong></p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p><strong>2、为什么为基本类型引入包装类</strong></p>
<ul>
<li>基本数据类型有方便之处，简单、高效。</li>
<li>但是Java中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是Object）</li>
</ul>
<p>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p>
<p><strong>3、包装类和基本数据类型之间的转换</strong></p>
<ul>
<li>包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型</li>
<li>包装类&lt;—new WrapperClass(primitive)– new WrapperClass(string)——基本数据类型</li>
</ul>
<p><strong>4、自动装箱和自动拆箱</strong></p>
<p>​    JDK1.5提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换。</p>
<p><strong>5、包装类还可以实现基本类型变量和字符串之间的转换</strong></p>
<ul>
<li>基本类型变量————String.valueof()————&gt;字符串</li>
<li>基本类型变量&lt;————WrapperClass.parseXxx(string)————字符串</li>
</ul>
<h3 id="34、Integer与int的区别"><a href="#34、Integer与int的区别" class="headerlink" title="34、Integer与int的区别"></a>34、Integer与int的区别</h3><p><strong>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</strong></p>
<p><strong>int的默认值为0，而Integer的默认值为null</strong>，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</p>
<p><strong>在Hibernate中，如果将OID定义为Integer类型</strong>，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p>
<p>另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<h3 id="35、java-sql-Date和java-util-Date的联系和区别"><a href="#35、java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="35、java.sql.Date和java.util.Date的联系和区别"></a>35、java.sql.Date和java.util.Date的联系和区别</h3><p>​    1）、java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQLDATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。</p>
<p>​    2）、JAVA里提供的日期和时间类java.sql.Date和java.sql.Timestamp,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包2002/05/22 5:00:57 PM的字段，读取日期时得到的是2002/05/22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。</p>
<p>以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 , 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象 , 用Equals方法可能返回false。<code>.sql.Timestamp</code>类比<code>java.util.Date</code>类精确度要高。</p>
<p><code>java.sql.Date </code>和<code>java.util.Date</code> 最大的不同在于<code>java.sql.Date </code>只记录日期，而没有具体这一天的时间。所以举例来说，如果当前是2009-12-24 23:20，你创建一个java.sql.Date 将只记下2009-12-24这个信息。若你需要保留时间进行JDBC操作，请使用<code>java.sql.Timestamp </code>代替。</p>
<p>总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分。</p>
<h3 id="36、递归应用题"><a href="#36、递归应用题" class="headerlink" title="36、递归应用题"></a>36、递归应用题</h3><p>题目 : 使用递归算法输出某个目录下及其子目录下所有文件.</p>
<p>递归 : 自动调用自己 , 需要定义递归出口.</p>
<p>题目分析 : 参数为一个指定的目录 . 输出所有文件列表;</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShowFile</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">/*
静态私有化方法的特点：
1. 方法只能在类内部使用。
2. 性能提高，静态的函数无需检测this指针是否为空。
（一般函数的第一个参数是对象本身，而静态的可以为null,不需要额外的检查)
*/</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>String path<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment" spellcheck="true">//list()方法是返回某个目录下的所有文件和目录的文件名，返回的是String数组</span>
        <span class="token comment" spellcheck="true">//listFiles()方法是返回某个目录下所有文件和目录的绝对路径，返回的是File数组</span>
        File f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        File<span class="token punctuation">[</span><span class="token punctuation">]</span> fs <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果没有文件,返回空;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token comment" spellcheck="true">//递归遍历输出</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>File file <span class="token operator">:</span> fs<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token comment" spellcheck="true">//如果是文件就直接打印出来,否则就递归循环</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span> 
                <span class="token function">test</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        String path <span class="token operator">=</span> <span class="token string">"E:\\生活\\图片"</span><span class="token punctuation">;</span>
        <span class="token function">test</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<h3 id="37、关于Java编译，下面哪一个正确（）"><a href="#37、关于Java编译，下面哪一个正确（）" class="headerlink" title="37、关于Java编译，下面哪一个正确（）"></a>37、关于Java编译，下面哪一个正确（）</h3><table>
<thead>
<tr>
<th>A</th>
<th>Java程序经编译后产生machine code (机器代码)</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>Java程序经编译后会生产byte code (字节码)</td>
</tr>
<tr>
<td>C</td>
<td>Java程序经编译后会产生DLL (动态链接库)</td>
</tr>
<tr>
<td>D</td>
<td>以上都不正确</td>
</tr>
</tbody></table>
<p>答案：B</p>
<p>分析： Java是解释型语言，编译出来的是字节码； 因此A不正确，C是C/C++语言编译动态链接库的文件为.DLL； 正确答案为B</p>
<h3 id="38、下列说法正确的有（）"><a href="#38、下列说法正确的有（）" class="headerlink" title="38、下列说法正确的有（）"></a>38、下列说法正确的有（）</h3><table>
<thead>
<tr>
<th>A</th>
<th>class中的construtor不可省略</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>construtor与class同名，但方法不能与class同名</td>
</tr>
<tr>
<td>C</td>
<td>construtor在一个对象被new时执行</td>
</tr>
<tr>
<td>D</td>
<td>一个class只能定义一个construtor</td>
</tr>
</tbody></table>
<p>答案：C</p>
<p>分析：A：如果class中的construtor省略不写，系统会默认提供一个无参构造</p>
<p>B：方法名可以与类名同名，只是不符合命名规范</p>
<p>D：一个class中可以定义N多个construtor，这些construtor构成构造方法的重载</p>
<h3 id="39、Java中接口的修饰符可以为（）"><a href="#39、Java中接口的修饰符可以为（）" class="headerlink" title="39、Java中接口的修饰符可以为（）"></a>39、Java中接口的修饰符可以为（）</h3><table>
<thead>
<tr>
<th>A</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>protected</td>
</tr>
<tr>
<td>C</td>
<td>final</td>
</tr>
<tr>
<td>D</td>
<td>abstract</td>
</tr>
</tbody></table>
<p>答案：D</p>
<p>分析：接口中的访问权限修饰符只可以是public或default</p>
<p>接口中的所有的方法必须要实现类实现，所以不能使用final</p>
<p>接口中所有的方法默认都是abstract的，所以接口可以使用abstract修饰，但通常abstract可以省略不写</p>
<h3 id="40、给定以下代码，程序将输出-（）"><a href="#40、给定以下代码，程序将输出-（）" class="headerlink" title="40、给定以下代码，程序将输出 （）"></a>40、给定以下代码，程序将输出 （）</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        B b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> </code></pre>
<table>
<thead>
<tr>
<th>A</th>
<th>不能通过编译</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>通过编译，输出AB</td>
</tr>
<tr>
<td>C</td>
<td>通过编译，输出B</td>
</tr>
<tr>
<td>D</td>
<td>通过编译，输出A</td>
</tr>
</tbody></table>
<p>答案：B</p>
<p>分析：在继承关系下，创建子类对象，先执行父类的构造方法，再执行子类的构造方法。</p>
<h2 id="41-60"><a href="#41-60" class="headerlink" title="41~60"></a>41~60</h2></div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">谢谢光临~</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>晓江</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/" title="java基础题">https://lxjblog.gitee.io/2021/02/22/java%E5%9F%BA%E7%A1%80%E9%A2%98/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="计算机网络"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">计算机网络</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/12/30/%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/" rel="next" title="配置SSL证书"><span class="post-nav-text">配置SSL证书</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>可以直接写评论内容喔~</span><br></div><div id="valine-container"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function initValine() {
  const valineConfig = {"enable":true,"appId":"71BKFg13iJQvNsFNLGzHmK67-gzGzoHsz","appKey":"IiQx2mfEEjefvbUfSd66nBHd","placeholder":"留下你的评论呗","avatar":"robohash","pageSize":10,"visitor":false,"highlight":true,"recordIP":false,"enableQQ":true,"el":"#valine-container","lang":"zh-cn"}
  valineConfig.path = window.location.pathname
  new Valine(valineConfig)
}
setTimeout(initValine, 1000)</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2020 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 晓江</span></div><div class="live_time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-08-04T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="总访客量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="总访问量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div><script>let date = new Date();
let today = (date.getMonth() + 1) + "-" + date.getDate()
if ("4-4,9-18".indexOf(today) !== -1) {
  document.documentElement.style.filter = "grayscale(1)";
}</script><div class="aplayer no-destroy" id="aplayer" data-id="5157675042" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="random" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="1" data-listmaxheight="340px" data-storagename="metingjs"></div></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>